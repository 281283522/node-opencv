<html>
<head>
  <title>Upgrade utils report</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="/usr/lib/node_modules/upgrade-utils/lib/assets/editor.css">
  <link rel="stylesheet" href="/usr/lib/node_modules/upgrade-utils/lib/assets/markdownPreview.css">
  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic' rel='stylesheet' type='text/css'>
</head>
<body>
  <div class="nav">
    <a href="http://nodesource.com" target="_blank"><img src="/usr/lib/node_modules/upgrade-utils/lib/assets/logo-white.svg"/></a>
    <p>Upgrade utils report</p>
  </div>

  <section id="diffs">
    <div>
      <h3 class="updated">Your files were updated according to the changes described below, to complete the update follow these steps:</h3>
      <ul>
        <li>Remove your Nan dependency with <code>npm remove nan --save</code>
        <li>Add Nan with <code>npm install nan --save</code> to get the last version
        <li>Rebuild your module <code>node-gyp rebuild</code>
        <li>Check if there are errors and manually fix those</li>
      </ul>
      <hr>
    </div>
      <div>
          <h3>Lines changed in src/BackgroundSubtractor.cc</h3>
          <div class="diff">
                <pre><code class="removed">- Persistent&lt;FunctionTemplate&gt; BackgroundSubtractorWrap::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; BackgroundSubtractorWrap::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(BackgroundSubtractorWrap::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(BackgroundSubtractorWrap::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;BackgroundSubtractor&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;BackgroundSubtractor&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_METHOD(ctor, &quot;createMOG&quot;, CreateMOG);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;applyMOG&quot;, ApplyMOG);
</code></pre>
                <pre><code class="added">+   Nan::SetMethod(ctor, &quot;createMOG&quot;, CreateMOG);
  Nan::SetPrototypeMethod(ctor, &quot;applyMOG&quot;, ApplyMOG);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;BackgroundSubtractor&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;BackgroundSubtractor&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   pt-&gt;Wrap(args.This());
</code></pre>
                <pre><code class="added">+   pt-&gt;Wrap(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(args.This());
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(info.This());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   // if(args.Length() &gt; 1){
</code></pre>
                <pre><code class="added">+   // if(info.Length() &gt; 1){
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; n &#x3D; NanNew(BackgroundSubtractorWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; n &#x3D; Nan::New(BackgroundSubtractorWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="removed">-   NanReturnValue( n );
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set( n );
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 0) {
    argv[0] &#x3D; NanNew(&quot;Input image missing&quot;);
    argv[1] &#x3D; NanNull();
    cb-&gt;Call(NanGetCurrentContext()-&gt;Global(), 2, argv);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 0) {
    argv[0] &#x3D; Nan::New(&quot;Input image missing&quot;).ToLocalChecked();
    argv[1] &#x3D; Nan::Null();
    cb-&gt;Call(Nan::GetCurrentContext()-&gt;Global(), 2, argv);
    return;
</code></pre>
                <pre><code class="removed">-         NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(fgMask);
</code></pre>
                <pre><code class="added">+         Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(fgMask);
</code></pre>
                <pre><code class="removed">-     if (Buffer::HasInstance(args[0])) {
      uint8_t *buf &#x3D; (uint8_t *) Buffer::Data(args[0]-&gt;ToObject());
      unsigned len &#x3D; Buffer::Length(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     if (Buffer::HasInstance(info[0])) {
      uint8_t *buf &#x3D; (uint8_t *) Buffer::Data(info[0]-&gt;ToObject());
      unsigned len &#x3D; Buffer::Length(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-       Matrix *_img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+       Matrix *_img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-       return NanThrowTypeError(&quot;Error loading file&quot;);
</code></pre>
                <pre><code class="added">+       return Nan::ThrowTypeError(&quot;Error loading file&quot;);
</code></pre>
                <pre><code class="removed">-     argv[0] &#x3D; NanNull();
</code></pre>
                <pre><code class="added">+     argv[0] &#x3D; Nan::Null();
</code></pre>
                <pre><code class="removed">-     cb-&gt;Call(NanGetCurrentContext()-&gt;Global(), 2, argv);
</code></pre>
                <pre><code class="added">+     cb-&gt;Call(Nan::GetCurrentContext()-&gt;Global(), 2, argv);
</code></pre>
                <pre><code class="removed">-     NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     return;
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Calib3D.cc</h3>
          <div class="diff">
                <pre><code class="removed">-       NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *matrix &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(matrixWrap);
</code></pre>
                <pre><code class="added">+       Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *matrix &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(matrixWrap);
</code></pre>
                <pre><code class="removed">-   Matrix* m &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(matrix-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix* m &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(matrix-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-           cv::Point2f(pt-&gt;Get(NanNew&lt;String&gt;(&quot;x&quot;))-&gt;ToNumber()-&gt;Value(),
              pt-&gt;Get(NanNew&lt;String&gt;(&quot;y&quot;))-&gt;ToNumber()-&gt;Value()));
</code></pre>
                <pre><code class="added">+           cv::Point2f(pt-&gt;Get(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked())-&gt;ToNumber()-&gt;Value(),
              pt-&gt;Get(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked())-&gt;ToNumber()-&gt;Value()));
</code></pre>
                <pre><code class="removed">-           cv::Point3f(pt-&gt;Get(NanNew&lt;String&gt;(&quot;x&quot;))-&gt;ToNumber()-&gt;Value(),
              pt-&gt;Get(NanNew&lt;String&gt;(&quot;y&quot;))-&gt;ToNumber()-&gt;Value(),
              pt-&gt;Get(NanNew&lt;String&gt;(&quot;z&quot;))-&gt;ToNumber()-&gt;Value()));
</code></pre>
                <pre><code class="added">+           cv::Point3f(pt-&gt;Get(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked())-&gt;ToNumber()-&gt;Value(),
              pt-&gt;Get(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked())-&gt;ToNumber()-&gt;Value(),
              pt-&gt;Get(Nan::New&lt;String&gt;(&quot;z&quot;).ToLocalChecked())-&gt;ToNumber()-&gt;Value()));
</code></pre>
                <pre><code class="removed">-   Persistent&lt;Object&gt; inner;
  Local&lt;Object&gt; obj &#x3D; NanNew&lt;Object&gt;();
  NanAssignPersistent(inner, obj);
</code></pre>
                <pre><code class="added">+   Nan::Persistent&lt;Object&gt; inner;
  Local&lt;Object&gt; obj &#x3D; Nan::New&lt;Object&gt;();
  inner.Reset(obj);
</code></pre>
                <pre><code class="removed">-   NODE_SET_METHOD(obj, &quot;findChessboardCorners&quot;, FindChessboardCorners);
  NODE_SET_METHOD(obj, &quot;drawChessboardCorners&quot;, DrawChessboardCorners);
  NODE_SET_METHOD(obj, &quot;calibrateCamera&quot;, CalibrateCamera);
  NODE_SET_METHOD(obj, &quot;solvePnP&quot;, SolvePnP);
  NODE_SET_METHOD(obj, &quot;getOptimalNewCameraMatrix&quot;, GetOptimalNewCameraMatrix);
  NODE_SET_METHOD(obj, &quot;stereoCalibrate&quot;, StereoCalibrate);
  NODE_SET_METHOD(obj, &quot;stereoRectify&quot;, StereoRectify);
  NODE_SET_METHOD(obj, &quot;computeCorrespondEpilines&quot;, ComputeCorrespondEpilines);
  NODE_SET_METHOD(obj, &quot;reprojectImageTo3d&quot;, ReprojectImageTo3D);
</code></pre>
                <pre><code class="added">+   Nan::SetMethod(obj, &quot;findChessboardCorners&quot;, FindChessboardCorners);
  Nan::SetMethod(obj, &quot;drawChessboardCorners&quot;, DrawChessboardCorners);
  Nan::SetMethod(obj, &quot;calibrateCamera&quot;, CalibrateCamera);
  Nan::SetMethod(obj, &quot;solvePnP&quot;, SolvePnP);
  Nan::SetMethod(obj, &quot;getOptimalNewCameraMatrix&quot;, GetOptimalNewCameraMatrix);
  Nan::SetMethod(obj, &quot;stereoCalibrate&quot;, StereoCalibrate);
  Nan::SetMethod(obj, &quot;stereoRectify&quot;, StereoRectify);
  Nan::SetMethod(obj, &quot;computeCorrespondEpilines&quot;, ComputeCorrespondEpilines);
  Nan::SetMethod(obj, &quot;reprojectImageTo3d&quot;, ReprojectImageTo3D);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;calib3d&quot;), obj);
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;calib3d&quot;).ToLocalChecked(), obj);
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     cv::Mat mat &#x3D; matFromMatrix(args[0]);
</code></pre>
                <pre><code class="added">+     cv::Mat mat &#x3D; matFromMatrix(info[0]);
</code></pre>
                <pre><code class="removed">-     cv::Size patternSize &#x3D; sizeFromArray(args[1]);
</code></pre>
                <pre><code class="added">+     cv::Size patternSize &#x3D; sizeFromArray(info[1]);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; ret &#x3D; NanNew&lt;Object&gt;();
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;found&quot;), NanNew&lt;Boolean&gt;(found));
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; ret &#x3D; Nan::New&lt;Object&gt;();
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;found&quot;).ToLocalChecked(), Nan::New&lt;Boolean&gt;(found));
</code></pre>
                <pre><code class="removed">-     Local&lt;Array&gt; cornersArray &#x3D; NanNew&lt;Array&gt;(corners.size());
</code></pre>
                <pre><code class="added">+     Local&lt;Array&gt; cornersArray &#x3D; Nan::New&lt;Array&gt;(corners.size());
</code></pre>
                <pre><code class="removed">-       Local&lt;Object&gt; point_data &#x3D; NanNew&lt;Object&gt;();
      point_data-&gt;Set(NanNew&lt;String&gt;(&quot;x&quot;), NanNew&lt;Number&gt;(corners[i].x));
      point_data-&gt;Set(NanNew&lt;String&gt;(&quot;y&quot;), NanNew&lt;Number&gt;(corners[i].y));
</code></pre>
                <pre><code class="added">+       Local&lt;Object&gt; point_data &#x3D; Nan::New&lt;Object&gt;();
      point_data-&gt;Set(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(corners[i].x));
      point_data-&gt;Set(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(corners[i].y));
</code></pre>
                <pre><code class="removed">-       cornersArray-&gt;Set(NanNew&lt;Number&gt;(i), point_data);
</code></pre>
                <pre><code class="added">+       cornersArray-&gt;Set(Nan::New&lt;Number&gt;(i), point_data);
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;corners&quot;), cornersArray);
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;corners&quot;).ToLocalChecked(), cornersArray);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(ret);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(ret);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     cv::Mat mat &#x3D; matFromMatrix(args[0]);
</code></pre>
                <pre><code class="added">+     cv::Mat mat &#x3D; matFromMatrix(info[0]);
</code></pre>
                <pre><code class="removed">-     cv::Size patternSize &#x3D; sizeFromArray(args[1]);
</code></pre>
                <pre><code class="added">+     cv::Size patternSize &#x3D; sizeFromArray(info[1]);
</code></pre>
                <pre><code class="removed">-     std::vector&lt;cv::Point2f&gt; corners &#x3D; points2fFromArray(args[2]);
</code></pre>
                <pre><code class="added">+     std::vector&lt;cv::Point2f&gt; corners &#x3D; points2fFromArray(info[2]);
</code></pre>
                <pre><code class="removed">-     bool patternWasFound &#x3D; args[3]-&gt;ToBoolean()-&gt;Value();
</code></pre>
                <pre><code class="added">+     bool patternWasFound &#x3D; info[3]-&gt;ToBoolean()-&gt;Value();
</code></pre>
                <pre><code class="removed">-     NanReturnValue(args[0]);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(info[0]);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-         points3fFromArrayOfArrays(args[0]);
</code></pre>
                <pre><code class="added">+         points3fFromArrayOfArrays(info[0]);
</code></pre>
                <pre><code class="removed">-         points2fFromArrayOfArrays(args[1]);
</code></pre>
                <pre><code class="added">+         points2fFromArrayOfArrays(info[1]);
</code></pre>
                <pre><code class="removed">-     cv::Size imageSize &#x3D; sizeFromArray(args[2]);
</code></pre>
                <pre><code class="added">+     cv::Size imageSize &#x3D; sizeFromArray(info[2]);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; ret &#x3D; NanNew&lt;Object&gt;();
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; ret &#x3D; Nan::New&lt;Object&gt;();
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;reprojectionError&quot;), NanNew&lt;Number&gt;(error));
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;reprojectionError&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(error));
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;K&quot;), KMatrixWrap);
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;K&quot;).ToLocalChecked(), KMatrixWrap);
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;distortion&quot;), distMatrixWrap);
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;distortion&quot;).ToLocalChecked(), distMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(ret);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(ret);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     std::vector&lt;cv::Point3f&gt; objectPoints &#x3D; points3fFromArray(args[0]);
</code></pre>
                <pre><code class="added">+     std::vector&lt;cv::Point3f&gt; objectPoints &#x3D; points3fFromArray(info[0]);
</code></pre>
                <pre><code class="removed">-     std::vector&lt;cv::Point2f&gt; imagePoints &#x3D; points2fFromArray(args[1]);
</code></pre>
                <pre><code class="added">+     std::vector&lt;cv::Point2f&gt; imagePoints &#x3D; points2fFromArray(info[1]);
</code></pre>
                <pre><code class="removed">-     cv::Mat K &#x3D; matFromMatrix(args[2]);
</code></pre>
                <pre><code class="added">+     cv::Mat K &#x3D; matFromMatrix(info[2]);
</code></pre>
                <pre><code class="removed">-     cv::Mat dist &#x3D; matFromMatrix(args[3]);
</code></pre>
                <pre><code class="added">+     cv::Mat dist &#x3D; matFromMatrix(info[3]);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; ret &#x3D; NanNew&lt;Object&gt;();
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; ret &#x3D; Nan::New&lt;Object&gt;();
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;rvec&quot;), rMatrixWrap);
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;rvec&quot;).ToLocalChecked(), rMatrixWrap);
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;tvec&quot;), tMatrixWrap);
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;tvec&quot;).ToLocalChecked(), tMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(ret);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(ret);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     cv::Mat Kin &#x3D; matFromMatrix(args[0]);
</code></pre>
                <pre><code class="added">+     cv::Mat Kin &#x3D; matFromMatrix(info[0]);
</code></pre>
                <pre><code class="removed">-     cv::Mat dist &#x3D; matFromMatrix(args[1]);
</code></pre>
                <pre><code class="added">+     cv::Mat dist &#x3D; matFromMatrix(info[1]);
</code></pre>
                <pre><code class="removed">-     cv::Size imageSize &#x3D; sizeFromArray(args[2]);
</code></pre>
                <pre><code class="added">+     cv::Size imageSize &#x3D; sizeFromArray(info[2]);
</code></pre>
                <pre><code class="removed">-     double alpha &#x3D; args[3]-&gt;ToNumber()-&gt;Value();
</code></pre>
                <pre><code class="added">+     double alpha &#x3D; info[3]-&gt;ToNumber()-&gt;Value();
</code></pre>
                <pre><code class="removed">-     cv::Size newImageSize &#x3D; sizeFromArray(args[4]);
</code></pre>
                <pre><code class="added">+     cv::Size newImageSize &#x3D; sizeFromArray(info[4]);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(KMatrixWrap);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(KMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-         points3fFromArrayOfArrays(args[0]);
</code></pre>
                <pre><code class="added">+         points3fFromArrayOfArrays(info[0]);
</code></pre>
                <pre><code class="removed">-         points2fFromArrayOfArrays(args[1]);
</code></pre>
                <pre><code class="added">+         points2fFromArrayOfArrays(info[1]);
</code></pre>
                <pre><code class="removed">-         points2fFromArrayOfArrays(args[2]);
</code></pre>
                <pre><code class="added">+         points2fFromArrayOfArrays(info[2]);
</code></pre>
                <pre><code class="removed">-     cv::Size imageSize &#x3D; sizeFromArray(args[3]);
</code></pre>
                <pre><code class="added">+     cv::Size imageSize &#x3D; sizeFromArray(info[3]);
</code></pre>
                <pre><code class="removed">-     if (args.Length() &gt;&#x3D; 8) {
      k1 &#x3D; matFromMatrix(args[4]);
      d1 &#x3D; matFromMatrix(args[5]);
</code></pre>
                <pre><code class="added">+     if (info.Length() &gt;&#x3D; 8) {
      k1 &#x3D; matFromMatrix(info[4]);
      d1 &#x3D; matFromMatrix(info[5]);
</code></pre>
                <pre><code class="removed">-       k2 &#x3D; matFromMatrix(args[6]);
      d2 &#x3D; matFromMatrix(args[7]);
</code></pre>
                <pre><code class="added">+       k2 &#x3D; matFromMatrix(info[6]);
      d2 &#x3D; matFromMatrix(info[7]);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; ret &#x3D; NanNew&lt;Object&gt;();
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; ret &#x3D; Nan::New&lt;Object&gt;();
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;K1&quot;), K1MatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;distortion1&quot;), d1MatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;K2&quot;), K2MatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;distortion2&quot;), d2MatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;R&quot;), RMatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;t&quot;), tMatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;E&quot;), EMatrixWrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;F&quot;), FMatrixWrap);
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;K1&quot;).ToLocalChecked(), K1MatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;distortion1&quot;).ToLocalChecked(), d1MatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;K2&quot;).ToLocalChecked(), K2MatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;distortion2&quot;).ToLocalChecked(), d2MatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;R&quot;).ToLocalChecked(), RMatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;t&quot;).ToLocalChecked(), tMatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;E&quot;).ToLocalChecked(), EMatrixWrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;F&quot;).ToLocalChecked(), FMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(ret);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(ret);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     cv::Mat K1 &#x3D; matFromMatrix(args[0]);
</code></pre>
                <pre><code class="added">+     cv::Mat K1 &#x3D; matFromMatrix(info[0]);
</code></pre>
                <pre><code class="removed">-     cv::Mat d1 &#x3D; matFromMatrix(args[1]);
</code></pre>
                <pre><code class="added">+     cv::Mat d1 &#x3D; matFromMatrix(info[1]);
</code></pre>
                <pre><code class="removed">-     cv::Mat K2 &#x3D; matFromMatrix(args[2]);
</code></pre>
                <pre><code class="added">+     cv::Mat K2 &#x3D; matFromMatrix(info[2]);
</code></pre>
                <pre><code class="removed">-     cv::Mat d2 &#x3D; matFromMatrix(args[3]);
</code></pre>
                <pre><code class="added">+     cv::Mat d2 &#x3D; matFromMatrix(info[3]);
</code></pre>
                <pre><code class="removed">-     cv::Size imageSize &#x3D; sizeFromArray(args[4]);
</code></pre>
                <pre><code class="added">+     cv::Size imageSize &#x3D; sizeFromArray(info[4]);
</code></pre>
                <pre><code class="removed">-     cv::Mat R &#x3D; matFromMatrix(args[5]);
</code></pre>
                <pre><code class="added">+     cv::Mat R &#x3D; matFromMatrix(info[5]);
</code></pre>
                <pre><code class="removed">-     cv::Mat t &#x3D; matFromMatrix(args[6]);
</code></pre>
                <pre><code class="added">+     cv::Mat t &#x3D; matFromMatrix(info[6]);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; ret &#x3D; NanNew&lt;Object&gt;();
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; ret &#x3D; Nan::New&lt;Object&gt;();
</code></pre>
                <pre><code class="removed">-     ret-&gt;Set(NanNew&lt;String&gt;(&quot;R1&quot;), matrixFromMat(R1));
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;R2&quot;), matrixFromMat(R2));
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;P1&quot;), matrixFromMat(P1));
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;P2&quot;), matrixFromMat(P2));
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;Q&quot;), matrixFromMat(Q));
</code></pre>
                <pre><code class="added">+     ret-&gt;Set(Nan::New&lt;String&gt;(&quot;R1&quot;).ToLocalChecked(), matrixFromMat(R1));
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;R2&quot;).ToLocalChecked(), matrixFromMat(R2));
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;P1&quot;).ToLocalChecked(), matrixFromMat(P1));
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;P2&quot;).ToLocalChecked(), matrixFromMat(P2));
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;Q&quot;).ToLocalChecked(), matrixFromMat(Q));
</code></pre>
                <pre><code class="removed">-     NanReturnValue(ret);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(ret);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     std::vector&lt;cv::Point2f&gt; points &#x3D; points2fFromArray(args[0]);
</code></pre>
                <pre><code class="added">+     std::vector&lt;cv::Point2f&gt; points &#x3D; points2fFromArray(info[0]);
</code></pre>
                <pre><code class="removed">-     int whichImage &#x3D; int(args[1]-&gt;ToNumber()-&gt;Value());
</code></pre>
                <pre><code class="added">+     int whichImage &#x3D; int(info[1]-&gt;ToNumber()-&gt;Value());
</code></pre>
                <pre><code class="removed">-     cv::Mat F &#x3D; matFromMatrix(args[2]);
</code></pre>
                <pre><code class="added">+     cv::Mat F &#x3D; matFromMatrix(info[2]);
</code></pre>
                <pre><code class="removed">-     Local&lt;Array&gt; linesArray &#x3D; NanNew&lt;Array&gt;(lines.size());
</code></pre>
                <pre><code class="added">+     Local&lt;Array&gt; linesArray &#x3D; Nan::New&lt;Array&gt;(lines.size());
</code></pre>
                <pre><code class="removed">-       Local&lt;Object&gt; line_data &#x3D; NanNew&lt;Object&gt;();
      line_data-&gt;Set(NanNew&lt;String&gt;(&quot;a&quot;), NanNew&lt;Number&gt;(lines[i][0]));
      line_data-&gt;Set(NanNew&lt;String&gt;(&quot;b&quot;), NanNew&lt;Number&gt;(lines[i][1]));
      line_data-&gt;Set(NanNew&lt;String&gt;(&quot;c&quot;), NanNew&lt;Number&gt;(lines[i][2]));
</code></pre>
                <pre><code class="added">+       Local&lt;Object&gt; line_data &#x3D; Nan::New&lt;Object&gt;();
      line_data-&gt;Set(Nan::New&lt;String&gt;(&quot;a&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(lines[i][0]));
      line_data-&gt;Set(Nan::New&lt;String&gt;(&quot;b&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(lines[i][1]));
      line_data-&gt;Set(Nan::New&lt;String&gt;(&quot;c&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(lines[i][2]));
</code></pre>
                <pre><code class="removed">-       linesArray-&gt;Set(NanNew&lt;Number&gt;(i), line_data);
</code></pre>
                <pre><code class="added">+       linesArray-&gt;Set(Nan::New&lt;Number&gt;(i), line_data);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(linesArray);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(linesArray);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     cv::Mat disparity &#x3D; matFromMatrix(args[0]);
</code></pre>
                <pre><code class="added">+     cv::Mat disparity &#x3D; matFromMatrix(info[0]);
</code></pre>
                <pre><code class="removed">-     cv::Mat Q &#x3D; matFromMatrix(args[1]);
</code></pre>
                <pre><code class="added">+     cv::Mat Q &#x3D; matFromMatrix(info[1]);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(depthImageMatrix);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(depthImageMatrix);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/BackgroundSubtractor.h</h3>
          <div class="diff">
                <pre><code class="removed">- class BackgroundSubtractorWrap: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class BackgroundSubtractorWrap: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/CamShift.cc</h3>
          <div class="diff">
                <pre><code class="removed">- Persistent&lt;FunctionTemplate&gt; TrackedObject::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; TrackedObject::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(TrackedObject::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(TrackedObject::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;TrackedObject&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;TrackedObject&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;track&quot;, Track);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;track&quot;, Track);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;TrackedObject&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;TrackedObject&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   Matrix* m &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix* m &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   if (args[1]-&gt;IsArray()) {
    Local&lt;Object&gt; v8rec &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[1]-&gt;IsArray()) {
    Local&lt;Object&gt; v8rec &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   if (args[2]-&gt;IsObject()) {
    Local&lt;Object&gt; opts &#x3D; args[2]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[2]-&gt;IsObject()) {
    Local&lt;Object&gt; opts &#x3D; info[2]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     if (opts-&gt;Get(NanNew(&quot;channel&quot;))-&gt;IsString()) {
      v8::String::Utf8Value c(opts-&gt;Get(NanNew(&quot;channel&quot;))-&gt;ToString());
</code></pre>
                <pre><code class="added">+     if (opts-&gt;Get(Nan::New(&quot;channel&quot;).ToLocalChecked())-&gt;IsString()) {
      v8::String::Utf8Value c(opts-&gt;Get(Nan::New(&quot;channel&quot;).ToLocalChecked())-&gt;ToString());
</code></pre>
                <pre><code class="removed">-   to-&gt;Wrap(args.This());
  NanReturnValue(args.This());
</code></pre>
                <pre><code class="added">+   to-&gt;Wrap(info.This());
  info.GetReturnValue().Set(info.This());
</code></pre>
                <pre><code class="removed">-   if (args.Length() !&#x3D; 1) {
    NanThrowTypeError(&quot;track takes an image param&quot;);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   if (info.Length() !&#x3D; 1) {
    Nan::ThrowTypeError(&quot;track takes an image param&quot;);
    return;
</code></pre>
                <pre><code class="removed">-   Matrix *im &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *im &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     return NanThrowTypeError(&quot;OPENCV ERROR: prev rectangle is illogical&quot;);
</code></pre>
                <pre><code class="added">+     return Nan::ThrowTypeError(&quot;OPENCV ERROR: prev rectangle is illogical&quot;);
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Array&gt; arr &#x3D; NanNew&lt;Array&gt;(4);
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Array&gt; arr &#x3D; Nan::New&lt;Array&gt;(4);
</code></pre>
                <pre><code class="removed">-   arr-&gt;Set(0, NanNew&lt;Number&gt;(bounds.x));
  arr-&gt;Set(1, NanNew&lt;Number&gt;(bounds.y));
  arr-&gt;Set(2, NanNew&lt;Number&gt;(bounds.x + bounds.width));
  arr-&gt;Set(3, NanNew&lt;Number&gt;(bounds.y + bounds.height));
</code></pre>
                <pre><code class="added">+   arr-&gt;Set(0, Nan::New&lt;Number&gt;(bounds.x));
  arr-&gt;Set(1, Nan::New&lt;Number&gt;(bounds.y));
  arr-&gt;Set(2, Nan::New&lt;Number&gt;(bounds.x + bounds.width));
  arr-&gt;Set(3, Nan::New&lt;Number&gt;(bounds.y + bounds.height));
</code></pre>
                <pre><code class="removed">-     arr-&gt;Set(i, NanNew&lt;Number&gt;(pts[i].x));
    arr-&gt;Set(i + 1, NanNew&lt;Number&gt;(pts[i].y));
</code></pre>
                <pre><code class="added">+     arr-&gt;Set(i, Nan::New&lt;Number&gt;(pts[i].x));
    arr-&gt;Set(i + 1, Nan::New&lt;Number&gt;(pts[i].y));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Calib3D.h</h3>
          <div class="diff">
                <pre><code class="removed">- class Calib3D: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class Calib3D: public Nan::ObjectWrap {
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/CascadeClassifierWrap.cc</h3>
          <div class="diff">
                <pre><code class="removed">- Persistent&lt;FunctionTemplate&gt; CascadeClassifierWrap::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; CascadeClassifierWrap::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt; (CascadeClassifierWrap::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt; (CascadeClassifierWrap::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;CascadeClassifier&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;CascadeClassifier&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;detectMultiScale&quot;, DetectMultiScale);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;detectMultiScale&quot;, DetectMultiScale);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;CascadeClassifier&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;CascadeClassifier&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    NanThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    Nan::ThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   CascadeClassifierWrap *pt &#x3D; new CascadeClassifierWrap(*args[0]);
  pt-&gt;Wrap(args.This());
  NanReturnValue( args.This() );
</code></pre>
                <pre><code class="added">+   CascadeClassifierWrap *pt &#x3D; new CascadeClassifierWrap(*info[0]);
  pt-&gt;Wrap(info.This());
  info.GetReturnValue().Set( info.This() );
</code></pre>
                <pre><code class="removed">-   filename &#x3D; std::string(*NanAsciiString(fileName-&gt;ToString()));
</code></pre>
                <pre><code class="added">+   filename &#x3D; std::string(*Nan::Utf8String(fileName-&gt;ToString()));
</code></pre>
                <pre><code class="removed">-     NanThrowTypeError(&quot;Error loading file&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowTypeError(&quot;Error loading file&quot;);
</code></pre>
                <pre><code class="removed">- class AsyncDetectMultiScale: public NanAsyncWorker {
</code></pre>
                <pre><code class="added">+ class AsyncDetectMultiScale: public Nan::AsyncWorker {
</code></pre>
                <pre><code class="removed">-   AsyncDetectMultiScale(NanCallback *callback, CascadeClassifierWrap *cc,
</code></pre>
                <pre><code class="added">+   AsyncDetectMultiScale(Nan::Callback *callback, CascadeClassifierWrap *cc,
</code></pre>
                <pre><code class="removed">-       NanAsyncWorker(callback),
</code></pre>
                <pre><code class="added">+       Nan::AsyncWorker(callback),
</code></pre>
                <pre><code class="removed">-     NanScope();
</code></pre>
                <pre><code class="added">+     Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-     v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew &lt; v8::Array &gt; (this-&gt;res.size());
</code></pre>
                <pre><code class="added">+     v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New &lt; v8::Array &gt; (this-&gt;res.size());
</code></pre>
                <pre><code class="removed">-       v8::Local &lt; v8::Object &gt; x &#x3D; NanNew&lt;v8::Object&gt;();
      x-&gt;Set(NanNew(&quot;x&quot;), NanNew &lt; Number &gt; (this-&gt;res[i].x));
      x-&gt;Set(NanNew(&quot;y&quot;), NanNew &lt; Number &gt; (this-&gt;res[i].y));
      x-&gt;Set(NanNew(&quot;width&quot;), NanNew &lt; Number &gt; (this-&gt;res[i].width));
      x-&gt;Set(NanNew(&quot;height&quot;), NanNew &lt; Number &gt; (this-&gt;res[i].height));
</code></pre>
                <pre><code class="added">+       v8::Local &lt; v8::Object &gt; x &#x3D; Nan::New&lt;v8::Object&gt;();
      x-&gt;Set(Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New &lt; Number &gt; (this-&gt;res[i].x));
      x-&gt;Set(Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New &lt; Number &gt; (this-&gt;res[i].y));
      x-&gt;Set(Nan::New(&quot;width&quot;).ToLocalChecked(), Nan::New &lt; Number &gt; (this-&gt;res[i].width));
      x-&gt;Set(Nan::New(&quot;height&quot;).ToLocalChecked(), Nan::New &lt; Number &gt; (this-&gt;res[i].height));
</code></pre>
                <pre><code class="removed">-     argv[0] &#x3D; NanNull();
</code></pre>
                <pre><code class="added">+     argv[0] &#x3D; Nan::Null();
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   CascadeClassifierWrap *self &#x3D; ObjectWrap::Unwrap&lt;CascadeClassifierWrap&gt; (args.This());
</code></pre>
                <pre><code class="added">+   CascadeClassifierWrap *self &#x3D; Nan::ObjectWrap::Unwrap&lt;CascadeClassifierWrap&gt; (info.This());
</code></pre>
                <pre><code class="removed">-   if (args.Length() &lt; 2) {
    NanThrowTypeError(&quot;detectMultiScale takes at least 2 args&quot;);
</code></pre>
                <pre><code class="added">+   if (info.Length() &lt; 2) {
    Nan::ThrowTypeError(&quot;detectMultiScale takes at least 2 info&quot;);
</code></pre>
                <pre><code class="removed">-   Matrix *im &#x3D; ObjectWrap::Unwrap &lt; Matrix &gt; (args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *im &#x3D; Nan::ObjectWrap::Unwrap &lt; Matrix &gt; (info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 2 &amp;&amp; args[2]-&gt;IsNumber()) {
    scale &#x3D; args[2]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 2 &amp;&amp; info[2]-&gt;IsNumber()) {
    scale &#x3D; info[2]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 3 &amp;&amp; args[3]-&gt;IsInt32()) {
    neighbors &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 3 &amp;&amp; info[3]-&gt;IsInt32()) {
    neighbors &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 5 &amp;&amp; args[4]-&gt;IsInt32() &amp;&amp; args[5]-&gt;IsInt32()) {
    minw &#x3D; args[4]-&gt;IntegerValue();
    minh &#x3D; args[5]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 5 &amp;&amp; info[4]-&gt;IsInt32() &amp;&amp; info[5]-&gt;IsInt32()) {
    minw &#x3D; info[4]-&gt;IntegerValue();
    minh &#x3D; info[5]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
</code></pre>
                <pre><code class="removed">-   NanAsyncQueueWorker( new AsyncDetectMultiScale(callback, self, im, scale,
</code></pre>
                <pre><code class="added">+   Nan::AsyncQueueWorker( new AsyncDetectMultiScale(callback, self, im, scale,
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/CascadeClassifierWrap.h</h3>
          <div class="diff">
                <pre><code class="removed">- class CascadeClassifierWrap: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class CascadeClassifierWrap: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/CamShift.h</h3>
          <div class="diff">
                <pre><code class="removed">- class TrackedObject: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class TrackedObject: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Constants.h</h3>
          <div class="diff">
                <pre><code class="removed">- class Constants: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class Constants: public Nan::ObjectWrap {
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Constants.cc</h3>
          <div class="diff">
                <pre><code class="removed">-   obj-&gt;Set(NanNew&lt;String&gt;(#C), NanNew&lt;Integer&gt;(C));
</code></pre>
                <pre><code class="added">+   obj-&gt;Set(Nan::New&lt;String&gt;(#C), Nan::New&lt;Integer&gt;(C));
</code></pre>
                <pre><code class="removed">-   obj-&gt;Set(NanNew&lt;String&gt;(#C), NanNew&lt;Integer&gt;((int)(cv::C)));
</code></pre>
                <pre><code class="added">+   obj-&gt;Set(Nan::New&lt;String&gt;(#C), Nan::New&lt;Integer&gt;((int)(cv::C)));
</code></pre>
                <pre><code class="removed">-   Persistent&lt;Object&gt; inner;
  Local&lt;Object&gt; obj &#x3D; NanNew&lt;Object&gt;();
  NanAssignPersistent(inner, obj);
</code></pre>
                <pre><code class="added">+   Nan::Persistent&lt;Object&gt; inner;
  Local&lt;Object&gt; obj &#x3D; Nan::New&lt;Object&gt;();
  inner.Reset(obj);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;Constants&quot;), obj);
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;Constants&quot;).ToLocalChecked(), obj);
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Contours.cc</h3>
          <div class="diff">
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; Contour::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; Contour::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(Contour::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(Contour::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;Contours&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;Contours&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;point&quot;, Point);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;size&quot;, Size);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;cornerCount&quot;, CornerCount);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;area&quot;, Area);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;arcLength&quot;, ArcLength);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;approxPolyDP&quot;, ApproxPolyDP);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;convexHull&quot;, ConvexHull);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;boundingRect&quot;, BoundingRect);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;minAreaRect&quot;, MinAreaRect);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;fitEllipse&quot;, FitEllipse);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;isConvex&quot;, IsConvex);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;moments&quot;, Moments);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;hierarchy&quot;, Hierarchy);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;serialize&quot;, Serialize);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;deserialize&quot;, Deserialize);
  target-&gt;Set(NanNew(&quot;Contours&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;point&quot;, Point);
  Nan::SetPrototypeMethod(ctor, &quot;size&quot;, Size);
  Nan::SetPrototypeMethod(ctor, &quot;cornerCount&quot;, CornerCount);
  Nan::SetPrototypeMethod(ctor, &quot;area&quot;, Area);
  Nan::SetPrototypeMethod(ctor, &quot;arcLength&quot;, ArcLength);
  Nan::SetPrototypeMethod(ctor, &quot;approxPolyDP&quot;, ApproxPolyDP);
  Nan::SetPrototypeMethod(ctor, &quot;convexHull&quot;, ConvexHull);
  Nan::SetPrototypeMethod(ctor, &quot;boundingRect&quot;, BoundingRect);
  Nan::SetPrototypeMethod(ctor, &quot;minAreaRect&quot;, MinAreaRect);
  Nan::SetPrototypeMethod(ctor, &quot;fitEllipse&quot;, FitEllipse);
  Nan::SetPrototypeMethod(ctor, &quot;isConvex&quot;, IsConvex);
  Nan::SetPrototypeMethod(ctor, &quot;moments&quot;, Moments);
  Nan::SetPrototypeMethod(ctor, &quot;hierarchy&quot;, Hierarchy);
  Nan::SetPrototypeMethod(ctor, &quot;serialize&quot;, Serialize);
  Nan::SetPrototypeMethod(ctor, &quot;deserialize&quot;, Deserialize);
  target-&gt;Set(Nan::New(&quot;Contours&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    NanThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    Nan::ThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   contours-&gt;Wrap(args.Holder());
  NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   contours-&gt;Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
  int index &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
  int index &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; data &#x3D; NanNew&lt;Object&gt;();
  data-&gt;Set(NanNew(&quot;x&quot;), NanNew&lt;Number&gt;(point.x));
  data-&gt;Set(NanNew(&quot;y&quot;), NanNew&lt;Number&gt;(point.y));
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; data &#x3D; Nan::New&lt;Object&gt;();
  data-&gt;Set(Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(point.x));
  data-&gt;Set(Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(point.y));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(data);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(data);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   Local&lt;Array&gt; data &#x3D; NanNew&lt;Array&gt;(points.size());
</code></pre>
                <pre><code class="added">+   Local&lt;Array&gt; data &#x3D; Nan::New&lt;Array&gt;(points.size());
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; point_data &#x3D; NanNew&lt;Object&gt;();
    point_data-&gt;Set(NanNew&lt;String&gt;(&quot;x&quot;), NanNew&lt;Number&gt;(points[i].x));
    point_data-&gt;Set(NanNew&lt;String&gt;(&quot;y&quot;), NanNew&lt;Number&gt;(points[i].y));
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; point_data &#x3D; Nan::New&lt;Object&gt;();
    point_data-&gt;Set(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(points[i].x));
    point_data-&gt;Set(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(points[i].y));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(data);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(data);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(self-&gt;contours.size()));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(self-&gt;contours.size()));
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(self-&gt;contours[pos].size()));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(self-&gt;contours[pos].size()));
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   // NanReturnValue(NanNew&lt;Number&gt;(contourArea(self-&gt;contours)));
  NanReturnValue(NanNew&lt;Number&gt;(contourArea(cv::Mat(self-&gt;contours[pos]))));
</code></pre>
                <pre><code class="added">+   // info.GetReturnValue().Set(Nan::New&lt;Number&gt;(contourArea(self-&gt;contours)));
  info.GetReturnValue().Set(Nan::New&lt;Number&gt;(contourArea(cv::Mat(self-&gt;contours[pos]))));
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
  bool isClosed &#x3D; args[1]-&gt;BooleanValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
  bool isClosed &#x3D; info[1]-&gt;BooleanValue();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(arcLength(cv::Mat(self-&gt;contours[pos]), isClosed)));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(arcLength(cv::Mat(self-&gt;contours[pos]), isClosed)));
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
  double epsilon &#x3D; args[1]-&gt;NumberValue();
  bool isClosed &#x3D; args[2]-&gt;BooleanValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
  double epsilon &#x3D; info[1]-&gt;NumberValue();
  bool isClosed &#x3D; info[2]-&gt;BooleanValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   int pos &#x3D; args[0]-&gt;NumberValue();
  bool clockwise &#x3D; args[1]-&gt;BooleanValue();
</code></pre>
                <pre><code class="added">+   int pos &#x3D; info[0]-&gt;NumberValue();
  bool clockwise &#x3D; info[1]-&gt;BooleanValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; rect &#x3D; NanNew&lt;Object&gt;();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; rect &#x3D; Nan::New&lt;Object&gt;();
</code></pre>
                <pre><code class="removed">-   rect-&gt;Set(NanNew(&quot;x&quot;), NanNew&lt;Number&gt;(bounding.x));
  rect-&gt;Set(NanNew(&quot;y&quot;), NanNew&lt;Number&gt;(bounding.y));
  rect-&gt;Set(NanNew(&quot;width&quot;), NanNew&lt;Number&gt;(bounding.width));
  rect-&gt;Set(NanNew(&quot;height&quot;), NanNew&lt;Number&gt;(bounding.height));
</code></pre>
                <pre><code class="added">+   rect-&gt;Set(Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(bounding.x));
  rect-&gt;Set(Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(bounding.y));
  rect-&gt;Set(Nan::New(&quot;width&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(bounding.width));
  rect-&gt;Set(Nan::New(&quot;height&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(bounding.height));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(rect);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(rect);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; rect &#x3D; NanNew&lt;Object&gt;();
  rect-&gt;Set(NanNew(&quot;angle&quot;), NanNew&lt;Number&gt;(minimum.angle));
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; rect &#x3D; Nan::New&lt;Object&gt;();
  rect-&gt;Set(Nan::New(&quot;angle&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(minimum.angle));
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; size &#x3D; NanNew&lt;Object&gt;();
  size-&gt;Set(NanNew(&quot;height&quot;), NanNew&lt;Number&gt;(minimum.size.height));
  size-&gt;Set(NanNew(&quot;width&quot;), NanNew&lt;Number&gt;(minimum.size.width));
  rect-&gt;Set(NanNew(&quot;size&quot;), size);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; size &#x3D; Nan::New&lt;Object&gt;();
  size-&gt;Set(Nan::New(&quot;height&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(minimum.size.height));
  size-&gt;Set(Nan::New(&quot;width&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(minimum.size.width));
  rect-&gt;Set(Nan::New(&quot;size&quot;).ToLocalChecked(), size);
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; center &#x3D; NanNew&lt;Object&gt;();
  center-&gt;Set(NanNew(&quot;x&quot;), NanNew&lt;Number&gt;(minimum.center.x));
  center-&gt;Set(NanNew(&quot;y&quot;), NanNew&lt;Number&gt;(minimum.center.y));
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; center &#x3D; Nan::New&lt;Object&gt;();
  center-&gt;Set(Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(minimum.center.x));
  center-&gt;Set(Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(minimum.center.y));
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Array&gt; points &#x3D; NanNew&lt;Array&gt;(4);
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Array&gt; points &#x3D; Nan::New&lt;Array&gt;(4);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; point &#x3D; NanNew&lt;Object&gt;();
    point-&gt;Set(NanNew(&quot;x&quot;), NanNew&lt;Number&gt;(rect_points[i].x));
    point-&gt;Set(NanNew(&quot;y&quot;), NanNew&lt;Number&gt;(rect_points[i].y));
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; point &#x3D; Nan::New&lt;Object&gt;();
    point-&gt;Set(Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(rect_points[i].x));
    point-&gt;Set(Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(rect_points[i].y));
</code></pre>
                <pre><code class="removed">-   rect-&gt;Set(NanNew(&quot;points&quot;), points);
</code></pre>
                <pre><code class="added">+   rect-&gt;Set(Nan::New(&quot;points&quot;).ToLocalChecked(), points);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(rect);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(rect);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; jsEllipse &#x3D; NanNew&lt;Object&gt;();
    jsEllipse-&gt;Set(NanNew(&quot;angle&quot;), NanNew&lt;Number&gt;(ellipse.angle));
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; jsEllipse &#x3D; Nan::New&lt;Object&gt;();
    jsEllipse-&gt;Set(Nan::New(&quot;angle&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(ellipse.angle));
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; size &#x3D; NanNew&lt;Object&gt;();
    size-&gt;Set(NanNew(&quot;height&quot;), NanNew&lt;Number&gt;(ellipse.size.height));
    size-&gt;Set(NanNew(&quot;width&quot;), NanNew&lt;Number&gt;(ellipse.size.width));
    jsEllipse-&gt;Set(NanNew(&quot;size&quot;), size);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; size &#x3D; Nan::New&lt;Object&gt;();
    size-&gt;Set(Nan::New(&quot;height&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(ellipse.size.height));
    size-&gt;Set(Nan::New(&quot;width&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(ellipse.size.width));
    jsEllipse-&gt;Set(Nan::New(&quot;size&quot;).ToLocalChecked(), size);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; center &#x3D; NanNew&lt;Object&gt;();
    center-&gt;Set(NanNew(&quot;x&quot;), NanNew&lt;Number&gt;(ellipse.center.x));
    center-&gt;Set(NanNew(&quot;y&quot;), NanNew&lt;Number&gt;(ellipse.center.y));
    jsEllipse-&gt;Set(NanNew(&quot;center&quot;), center);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; center &#x3D; Nan::New&lt;Object&gt;();
    center-&gt;Set(Nan::New(&quot;x&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(ellipse.center.x));
    center-&gt;Set(Nan::New(&quot;y&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(ellipse.center.y));
    jsEllipse-&gt;Set(Nan::New(&quot;center&quot;).ToLocalChecked(), center);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(jsEllipse);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(jsEllipse);
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Boolean&gt;(isContourConvex(cv::Mat(self-&gt;contours[pos]))));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Boolean&gt;(isContourConvex(cv::Mat(self-&gt;contours[pos]))));
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; res &#x3D; NanNew&lt;Object&gt;();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; res &#x3D; Nan::New&lt;Object&gt;();
</code></pre>
                <pre><code class="removed">-   res-&gt;Set(NanNew(&quot;m00&quot;), NanNew&lt;Number&gt;(mu.m00));
  res-&gt;Set(NanNew(&quot;m10&quot;), NanNew&lt;Number&gt;(mu.m10));
  res-&gt;Set(NanNew(&quot;m01&quot;), NanNew&lt;Number&gt;(mu.m01));
  res-&gt;Set(NanNew(&quot;m11&quot;), NanNew&lt;Number&gt;(mu.m11));
</code></pre>
                <pre><code class="added">+   res-&gt;Set(Nan::New(&quot;m00&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(mu.m00));
  res-&gt;Set(Nan::New(&quot;m10&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(mu.m10));
  res-&gt;Set(Nan::New(&quot;m01&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(mu.m01));
  res-&gt;Set(Nan::New(&quot;m11&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(mu.m11));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(res);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(res);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
  int pos &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
  int pos &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   Local&lt;Array&gt; res &#x3D; NanNew&lt;Array&gt;(4);
</code></pre>
                <pre><code class="added">+   Local&lt;Array&gt; res &#x3D; Nan::New&lt;Array&gt;(4);
</code></pre>
                <pre><code class="removed">-   res-&gt;Set(0, NanNew&lt;Number&gt;(hierarchy[0]));
  res-&gt;Set(1, NanNew&lt;Number&gt;(hierarchy[1]));
  res-&gt;Set(2, NanNew&lt;Number&gt;(hierarchy[2]));
  res-&gt;Set(3, NanNew&lt;Number&gt;(hierarchy[3]));
</code></pre>
                <pre><code class="added">+   res-&gt;Set(0, Nan::New&lt;Number&gt;(hierarchy[0]));
  res-&gt;Set(1, Nan::New&lt;Number&gt;(hierarchy[1]));
  res-&gt;Set(2, Nan::New&lt;Number&gt;(hierarchy[2]));
  res-&gt;Set(3, Nan::New&lt;Number&gt;(hierarchy[3]));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(res);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(res);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Local&lt;Array&gt; contours_data &#x3D; NanNew&lt;Array&gt;(self-&gt;contours.size());
</code></pre>
                <pre><code class="added">+   Local&lt;Array&gt; contours_data &#x3D; Nan::New&lt;Array&gt;(self-&gt;contours.size());
</code></pre>
                <pre><code class="removed">-     Local&lt;Array&gt; contour_data &#x3D; NanNew&lt;Array&gt;(points.size());
</code></pre>
                <pre><code class="added">+     Local&lt;Array&gt; contour_data &#x3D; Nan::New&lt;Array&gt;(points.size());
</code></pre>
                <pre><code class="removed">-       Local&lt;Array&gt; point_data &#x3D; NanNew&lt;Array&gt;(2);
      point_data-&gt;Set(0, NanNew&lt;Number&gt;(points[j].x));
      point_data-&gt;Set(1, NanNew&lt;Number&gt;(points[j].y));
</code></pre>
                <pre><code class="added">+       Local&lt;Array&gt; point_data &#x3D; Nan::New&lt;Array&gt;(2);
      point_data-&gt;Set(0, Nan::New&lt;Number&gt;(points[j].x));
      point_data-&gt;Set(1, Nan::New&lt;Number&gt;(points[j].y));
</code></pre>
                <pre><code class="removed">-   Local&lt;Array&gt; hierarchy_data &#x3D; NanNew&lt;Array&gt;(self-&gt;hierarchy.size());
</code></pre>
                <pre><code class="added">+   Local&lt;Array&gt; hierarchy_data &#x3D; Nan::New&lt;Array&gt;(self-&gt;hierarchy.size());
</code></pre>
                <pre><code class="removed">-     Local&lt;Array&gt; contour_data &#x3D; NanNew&lt;Array&gt;(4);
    contour_data-&gt;Set(0, NanNew&lt;Number&gt;(self-&gt;hierarchy[i][0]));
    contour_data-&gt;Set(1, NanNew&lt;Number&gt;(self-&gt;hierarchy[i][1]));
    contour_data-&gt;Set(2, NanNew&lt;Number&gt;(self-&gt;hierarchy[i][2]));
    contour_data-&gt;Set(3, NanNew&lt;Number&gt;(self-&gt;hierarchy[i][3]));
</code></pre>
                <pre><code class="added">+     Local&lt;Array&gt; contour_data &#x3D; Nan::New&lt;Array&gt;(4);
    contour_data-&gt;Set(0, Nan::New&lt;Number&gt;(self-&gt;hierarchy[i][0]));
    contour_data-&gt;Set(1, Nan::New&lt;Number&gt;(self-&gt;hierarchy[i][1]));
    contour_data-&gt;Set(2, Nan::New&lt;Number&gt;(self-&gt;hierarchy[i][2]));
    contour_data-&gt;Set(3, Nan::New&lt;Number&gt;(self-&gt;hierarchy[i][3]));
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; data &#x3D; NanNew&lt;Object&gt;();
  data-&gt;Set(NanNew&lt;String&gt;(&quot;contours&quot;), contours_data);
  data-&gt;Set(NanNew&lt;String&gt;(&quot;hierarchy&quot;), hierarchy_data);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; data &#x3D; Nan::New&lt;Object&gt;();
  data-&gt;Set(Nan::New&lt;String&gt;(&quot;contours&quot;).ToLocalChecked(), contours_data);
  data-&gt;Set(Nan::New&lt;String&gt;(&quot;hierarchy&quot;).ToLocalChecked(), hierarchy_data);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(data);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(data);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Contour *self &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Contour *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Handle&lt;Object&gt; data &#x3D; Handle&lt;Object&gt;::Cast(args[0]);
</code></pre>
                <pre><code class="added">+   Handle&lt;Object&gt; data &#x3D; Handle&lt;Object&gt;::Cast(info[0]);
</code></pre>
                <pre><code class="removed">-   Handle&lt;Array&gt; contours_data &#x3D; Handle&lt;Array&gt;::Cast(data-&gt;Get(NanNew&lt;String&gt;(&quot;contours&quot;)));
  Handle&lt;Array&gt; hierarchy_data &#x3D; Handle&lt;Array&gt;::Cast(data-&gt;Get(NanNew&lt;String&gt;(&quot;hierarchy&quot;)));
</code></pre>
                <pre><code class="added">+   Handle&lt;Array&gt; contours_data &#x3D; Handle&lt;Array&gt;::Cast(data-&gt;Get(Nan::New&lt;String&gt;(&quot;contours&quot;).ToLocalChecked()));
  Handle&lt;Array&gt; hierarchy_data &#x3D; Handle&lt;Array&gt;::Cast(data-&gt;Get(Nan::New&lt;String&gt;(&quot;hierarchy&quot;).ToLocalChecked()));
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Contours.h</h3>
          <div class="diff">
                <pre><code class="removed">- class Contour: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class Contour: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/FaceRecognizer.cc</h3>
          <div class="diff">
                <pre><code class="removed">-     std::string filename &#x3D; std::string(*NanAsciiString(v-&gt;ToString()));
</code></pre>
                <pre><code class="added">+     std::string filename &#x3D; std::string(*Nan::Utf8String(v-&gt;ToString()));
</code></pre>
                <pre><code class="removed">-     Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(v-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(v-&gt;ToObject());
</code></pre>
                <pre><code class="removed">- Persistent&lt;FunctionTemplate&gt; FaceRecognizerWrap::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; FaceRecognizerWrap::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(FaceRecognizerWrap::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(FaceRecognizerWrap::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;FaceRecognizer&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;FaceRecognizer&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_METHOD(ctor, &quot;createLBPHFaceRecognizer&quot;, CreateLBPH);
  NODE_SET_METHOD(ctor, &quot;createEigenFaceRecognizer&quot;, CreateEigen);
  NODE_SET_METHOD(ctor, &quot;createFisherFaceRecognizer&quot;, CreateFisher);
</code></pre>
                <pre><code class="added">+   Nan::SetMethod(ctor, &quot;createLBPHFaceRecognizer&quot;, CreateLBPH);
  Nan::SetMethod(ctor, &quot;createEigenFaceRecognizer&quot;, CreateEigen);
  Nan::SetMethod(ctor, &quot;createFisherFaceRecognizer&quot;, CreateFisher);
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;trainSync&quot;, TrainSync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;updateSync&quot;, UpdateSync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;predictSync&quot;, PredictSync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;saveSync&quot;, SaveSync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;loadSync&quot;, LoadSync);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;trainSync&quot;, TrainSync);
  Nan::SetPrototypeMethod(ctor, &quot;updateSync&quot;, UpdateSync);
  Nan::SetPrototypeMethod(ctor, &quot;predictSync&quot;, PredictSync);
  Nan::SetPrototypeMethod(ctor, &quot;saveSync&quot;, SaveSync);
  Nan::SetPrototypeMethod(ctor, &quot;loadSync&quot;, LoadSync);
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;getMat&quot;, GetMat);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;getMat&quot;, GetMat);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;FaceRecognizer&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;FaceRecognizer&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   pt-&gt;Wrap(args.This());
  NanReturnValue(args.This());
</code></pre>
                <pre><code class="added">+   pt-&gt;Wrap(info.This());
  info.GetReturnValue().Set(info.This());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; n &#x3D; NanNew(FaceRecognizerWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; n &#x3D; Nan::New(FaceRecognizerWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="removed">-   NanReturnValue( n );
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set( n );
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; n &#x3D; NanNew(FaceRecognizerWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; n &#x3D; Nan::New(FaceRecognizerWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="removed">-   NanReturnValue( n );
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set( n );
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; n &#x3D; NanNew(FaceRecognizerWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; n &#x3D; Nan::New(FaceRecognizerWrap::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="removed">-   NanReturnValue( n );
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set( n );
</code></pre>
                <pre><code class="removed">- Handle&lt;Value&gt; UnwrapTrainingData(_NAN_METHOD_ARGS_TYPE args,
</code></pre>
                <pre><code class="added">+ Handle&lt;Value&gt; UnwrapTrainingData(Nan::NAN_METHOD_ARGS_TYPE info,
</code></pre>
                <pre><code class="removed">-   if (args.Length() &lt; 1 || !args[0]-&gt;IsArray()) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &lt; 1 || !info[0]-&gt;IsArray()) {
</code></pre>
                <pre><code class="removed">-   // const Local&lt;Array&gt; tuples &#x3D; v8::Array::Cast(*args[0]);
  const Local&lt;Array&gt; tuples &#x3D; Local&lt;Array&gt;::Cast(args[0]);
</code></pre>
                <pre><code class="added">+   // const Local&lt;Array&gt; tuples &#x3D; v8::Array::Cast(*info[0]);
  const Local&lt;Array&gt; tuples &#x3D; Local&lt;Array&gt;::Cast(info[0]);
</code></pre>
                <pre><code class="removed">-   return NanUndefined();
</code></pre>
                <pre><code class="added">+   return Nan::Undefined();
</code></pre>
                <pre><code class="removed">-   Handle&lt;Value&gt; exception &#x3D; UnwrapTrainingData(args, &amp;images, &amp;labels);
</code></pre>
                <pre><code class="added">+   Handle&lt;Value&gt; exception &#x3D; UnwrapTrainingData(info, &amp;images, &amp;labels);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(exception);  // FIXME: not too sure about returning exceptions like this
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(exception);  // FIXME: not too sure about returning exceptions like this
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   Handle&lt;Value&gt; exception &#x3D; UnwrapTrainingData(args, &amp;images, &amp;labels);
</code></pre>
                <pre><code class="added">+   Handle&lt;Value&gt; exception &#x3D; UnwrapTrainingData(info, &amp;images, &amp;labels);
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   cv::Mat im &#x3D; fromMatrixOrFilename(args[0]);  // TODO CHECK!
</code></pre>
                <pre><code class="added">+   cv::Mat im &#x3D; fromMatrixOrFilename(info[0]);  // TODO CHECK!
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Object&gt; res &#x3D; NanNew&lt;Object&gt;();
  res-&gt;Set(NanNew(&quot;id&quot;), NanNew&lt;Number&gt;(predictedLabel));
  res-&gt;Set(NanNew(&quot;confidence&quot;), NanNew&lt;Number&gt;(confidence));
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Object&gt; res &#x3D; Nan::New&lt;Object&gt;();
  res-&gt;Set(Nan::New(&quot;id&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(predictedLabel));
  res-&gt;Set(Nan::New(&quot;confidence&quot;).ToLocalChecked(), Nan::New&lt;Number&gt;(confidence));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(res);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(res);
</code></pre>
                <pre><code class="removed">-   if (!args[0]-&gt;IsString()) {
</code></pre>
                <pre><code class="added">+   if (!info[0]-&gt;IsString()) {
</code></pre>
                <pre><code class="removed">-   std::string filename &#x3D; std::string(*NanAsciiString(args[0]-&gt;ToString()));
</code></pre>
                <pre><code class="added">+   std::string filename &#x3D; std::string(*Nan::Utf8String(info[0]-&gt;ToString()));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   if (!args[0]-&gt;IsString()) {
</code></pre>
                <pre><code class="added">+   if (!info[0]-&gt;IsString()) {
</code></pre>
                <pre><code class="removed">-   std::string filename &#x3D; std::string(*NanAsciiString(args[0]-&gt;ToString()));
</code></pre>
                <pre><code class="added">+   std::string filename &#x3D; std::string(*Nan::Utf8String(info[0]-&gt;ToString()));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   if (!args[0]-&gt;IsString()) {
</code></pre>
                <pre><code class="added">+   if (!info[0]-&gt;IsString()) {
</code></pre>
                <pre><code class="removed">-   std::string key &#x3D; std::string(*NanAsciiString(args[0]-&gt;ToString()));
</code></pre>
                <pre><code class="added">+   std::string key &#x3D; std::string(*Nan::Utf8String(info[0]-&gt;ToString()));
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; im &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; im &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(im);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(im);
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/FaceRecognizer.h</h3>
          <div class="diff">
                <pre><code class="removed">- class FaceRecognizerWrap: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class FaceRecognizerWrap: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Features2d.cc</h3>
          <div class="diff">
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   NODE_SET_METHOD(target, &quot;ImageSimilarity&quot;, Similarity);
</code></pre>
                <pre><code class="added">+   Nan::SetMethod(target, &quot;ImageSimilarity&quot;, Similarity);
</code></pre>
                <pre><code class="removed">- class AsyncDetectSimilarity: public NanAsyncWorker {
</code></pre>
                <pre><code class="added">+ class AsyncDetectSimilarity: public Nan::AsyncWorker {
</code></pre>
                <pre><code class="removed">-   AsyncDetectSimilarity(NanCallback *callback, cv::Mat image1, cv::Mat image2) :
      NanAsyncWorker(callback),
</code></pre>
                <pre><code class="added">+   AsyncDetectSimilarity(Nan::Callback *callback, cv::Mat image1, cv::Mat image2) :
      Nan::AsyncWorker(callback),
</code></pre>
                <pre><code class="removed">-     NanScope();
</code></pre>
                <pre><code class="added">+     Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-     argv[0] &#x3D; NanNull();
    argv[1] &#x3D; NanNew&lt;Number&gt;(dissimilarity);
</code></pre>
                <pre><code class="added">+     argv[0] &#x3D; Nan::Null();
    argv[1] &#x3D; Nan::New&lt;Number&gt;(dissimilarity);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   cv::Mat image1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject())-&gt;mat;
  cv::Mat image2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject())-&gt;mat;
</code></pre>
                <pre><code class="added">+   cv::Mat image1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject())-&gt;mat;
  cv::Mat image2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject())-&gt;mat;
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
</code></pre>
                <pre><code class="removed">-   NanAsyncQueueWorker( new AsyncDetectSimilarity(callback, image1, image2) );
  NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   Nan::AsyncQueueWorker( new AsyncDetectSimilarity(callback, image1, image2) );
  return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Features2d.h</h3>
          <div class="diff">
                <pre><code class="removed">- class Features: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class Features: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/HighGUI.cc</h3>
          <div class="diff">
                <pre><code class="removed">- Persistent&lt;FunctionTemplate&gt; NamedWindow::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; NamedWindow::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(NamedWindow::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(NamedWindow::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;NamedWindow&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;NamedWindow&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;show&quot;, Show);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;destroy&quot;, Destroy);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;blockingWaitKey&quot;, BlockingWaitKey);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;show&quot;, Show);
  Nan::SetPrototypeMethod(ctor, &quot;destroy&quot;, Destroy);
  Nan::SetPrototypeMethod(ctor, &quot;blockingWaitKey&quot;, BlockingWaitKey);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;NamedWindow&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;NamedWindow&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 1) {
    win &#x3D; new NamedWindow(std::string(*NanAsciiString(args[0]-&gt;ToString())), 0);
  } else {  //if (args.Length() &#x3D;&#x3D; 2){
    win &#x3D; new NamedWindow(std::string(*NanAsciiString(args[0]-&gt;ToString())), 0);
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 1) {
    win &#x3D; new NamedWindow(std::string(*Nan::Utf8String(info[0]-&gt;ToString())), 0);
  } else {  //if (info.Length() &#x3D;&#x3D; 2){
    win &#x3D; new NamedWindow(std::string(*Nan::Utf8String(info[0]-&gt;ToString())), 0);
</code></pre>
                <pre><code class="removed">-   win-&gt;Wrap(args.Holder());
  NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   win-&gt;Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-   Matrix *im &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *im &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 1) {
    time &#x3D; args[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 1) {
    time &#x3D; info[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-     if (args.Length() &gt; 0) {
      time &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     if (info.Length() &gt; 0) {
      time &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(res));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(res));
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/HighGUI.h</h3>
          <div class="diff">
                <pre><code class="removed">- class NamedWindow: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class NamedWindow: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/ImgProc.cc</h3>
          <div class="diff">
                <pre><code class="removed">-   Persistent&lt;Object&gt; inner;
  Local&lt;Object&gt; obj &#x3D; NanNew&lt;Object&gt;();
  NanAssignPersistent(inner, obj);
</code></pre>
                <pre><code class="added">+   Nan::Persistent&lt;Object&gt; inner;
  Local&lt;Object&gt; obj &#x3D; Nan::New&lt;Object&gt;();
  inner.Reset(obj);
</code></pre>
                <pre><code class="removed">-   NODE_SET_METHOD(obj, &quot;undistort&quot;, Undistort);
  NODE_SET_METHOD(obj, &quot;initUndistortRectifyMap&quot;, InitUndistortRectifyMap);
  NODE_SET_METHOD(obj, &quot;remap&quot;, Remap);
</code></pre>
                <pre><code class="added">+   Nan::SetMethod(obj, &quot;undistort&quot;, Undistort);
  Nan::SetMethod(obj, &quot;initUndistortRectifyMap&quot;, InitUndistortRectifyMap);
  Nan::SetMethod(obj, &quot;remap&quot;, Remap);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;imgproc&quot;), obj);
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;imgproc&quot;).ToLocalChecked(), obj);
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     Matrix* m0 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m0 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; outMatrixWrap &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *outMatrix &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(outMatrixWrap);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; outMatrixWrap &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *outMatrix &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(outMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(outMatrixWrap);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(outMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     Matrix* m0 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m0 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m3 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[3]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m3 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[3]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     if (args[4]-&gt;IsArray()) {
      Local&lt;Object&gt; v8sz &#x3D; args[4]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+     if (info[4]-&gt;IsArray()) {
      Local&lt;Object&gt; v8sz &#x3D; info[4]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     int m1type &#x3D; args[5]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     int m1type &#x3D; info[5]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; map1Wrap &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *map1Matrix &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(map1Wrap);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; map1Wrap &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *map1Matrix &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(map1Wrap);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; map2Wrap &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *map2Matrix &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(map2Wrap);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; map2Wrap &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *map2Matrix &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(map2Wrap);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; ret &#x3D; NanNew&lt;Object&gt;();
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;map1&quot;), map1Wrap);
    ret-&gt;Set(NanNew&lt;String&gt;(&quot;map2&quot;), map2Wrap);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; ret &#x3D; Nan::New&lt;Object&gt;();
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;map1&quot;).ToLocalChecked(), map1Wrap);
    ret-&gt;Set(Nan::New&lt;String&gt;(&quot;map2&quot;).ToLocalChecked(), map2Wrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(ret);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(ret);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-     Matrix* m0 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m0 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     int interpolation &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     int interpolation &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; outMatrixWrap &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *outMatrix &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(outMatrixWrap);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; outMatrixWrap &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *outMatrix &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(outMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(outMatrixWrap);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(outMatrixWrap);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/ImgProc.h</h3>
          <div class="diff">
                <pre><code class="removed">- class ImgProc: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class ImgProc: public Nan::ObjectWrap {
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Matrix.h</h3>
          <div class="diff">
                <pre><code class="removed">- class Matrix: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class Matrix: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="removed">-    static Handle&lt;Value&gt; Val(const Arguments&amp; args);
   static Handle&lt;Value&gt; RowRange(const Arguments&amp; args);
   static Handle&lt;Value&gt; ColRange(const Arguments&amp; args);
   static Handle&lt;Value&gt; Diag(const Arguments&amp; args);
   static Handle&lt;Value&gt; Clone(const Arguments&amp; args);
   static Handle&lt;Value&gt; CopyTo(const Arguments&amp; args);
   static Handle&lt;Value&gt; ConvertTo(const Arguments&amp; args);
   static Handle&lt;Value&gt; AssignTo(const Arguments&amp; args);
   static Handle&lt;Value&gt; SetTo(const Arguments&amp; args);
   static Handle&lt;Value&gt; Reshape(const Arguments&amp; args);
   static Handle&lt;Value&gt; Transpose(const Arguments&amp; args);
   static Handle&lt;Value&gt; Invert(const Arguments&amp; args);
   static Handle&lt;Value&gt; Multiply(const Arguments&amp; args);
   static Handle&lt;Value&gt; Cross(const Arguments&amp; args);
   static Handle&lt;Value&gt; Dot(const Arguments&amp; args);
   static Handle&lt;Value&gt; Zeroes(const Arguments&amp; args);
   static Handle&lt;Value&gt; Ones(const Arguments&amp; args);
</code></pre>
                <pre><code class="added">+    static Handle&lt;Value&gt; Val(const Arguments&amp; info);
   static Handle&lt;Value&gt; RowRange(const Arguments&amp; info);
   static Handle&lt;Value&gt; ColRange(const Arguments&amp; info);
   static Handle&lt;Value&gt; Diag(const Arguments&amp; info);
   static Handle&lt;Value&gt; Clone(const Arguments&amp; info);
   static Handle&lt;Value&gt; CopyTo(const Arguments&amp; info);
   static Handle&lt;Value&gt; ConvertTo(const Arguments&amp; info);
   static Handle&lt;Value&gt; AssignTo(const Arguments&amp; info);
   static Handle&lt;Value&gt; SetTo(const Arguments&amp; info);
   static Handle&lt;Value&gt; Reshape(const Arguments&amp; info);
   static Handle&lt;Value&gt; Transpose(const Arguments&amp; info);
   static Handle&lt;Value&gt; Invert(const Arguments&amp; info);
   static Handle&lt;Value&gt; Multiply(const Arguments&amp; info);
   static Handle&lt;Value&gt; Cross(const Arguments&amp; info);
   static Handle&lt;Value&gt; Dot(const Arguments&amp; info);
   static Handle&lt;Value&gt; Zeroes(const Arguments&amp; info);
   static Handle&lt;Value&gt; Ones(const Arguments&amp; info);
</code></pre>
                <pre><code class="removed">-    static Handle&lt;Value&gt; PushBack(const Arguments&amp; args);
   static Handle&lt;Value&gt; PopBack(const Arguments&amp; args);
   static Handle&lt;Value&gt; Total(const Arguments&amp; args);
   static Handle&lt;Value&gt; IsContinous(const Arguments&amp; args);
   static Handle&lt;Value&gt; Type(const Arguments&amp; args);
   static Handle&lt;Value&gt; Depth(const Arguments&amp; args);
   static Handle&lt;Value&gt; Channels(const Arguments&amp; args);
   static Handle&lt;Value&gt; StepOne(const Arguments&amp; args);
   static Handle&lt;Value&gt; GetPerspectiveTransform(const Arguments&amp; args);
   static Handle&lt;Value&gt; WarpPerspective(const Arguments&amp; args);
</code></pre>
                <pre><code class="added">+    static Handle&lt;Value&gt; PushBack(const Arguments&amp; info);
   static Handle&lt;Value&gt; PopBack(const Arguments&amp; info);
   static Handle&lt;Value&gt; Total(const Arguments&amp; info);
   static Handle&lt;Value&gt; IsContinous(const Arguments&amp; info);
   static Handle&lt;Value&gt; Type(const Arguments&amp; info);
   static Handle&lt;Value&gt; Depth(const Arguments&amp; info);
   static Handle&lt;Value&gt; Channels(const Arguments&amp; info);
   static Handle&lt;Value&gt; StepOne(const Arguments&amp; info);
   static Handle&lt;Value&gt; GetPerspectiveTransform(const Arguments&amp; info);
   static Handle&lt;Value&gt; WarpPerspective(const Arguments&amp; info);
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/OpenCV.cc</h3>
          <div class="diff">
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew&lt;String&gt;(&quot;version&quot;), NanNew&lt;String&gt;(out, n));
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New&lt;String&gt;(&quot;version&quot;).ToLocalChecked(), Nan::New&lt;String&gt;(out, n));
</code></pre>
                <pre><code class="removed">-   NODE_SET_METHOD(target, &quot;readImage&quot;, ReadImage);
</code></pre>
                <pre><code class="added">+   Nan::SetMethod(target, &quot;readImage&quot;, ReadImage);
</code></pre>
                <pre><code class="removed">-   NanEscapableScope();
</code></pre>
                <pre><code class="added">+   Nan::EscapableHandleScope scope;
</code></pre>
                <pre><code class="removed">-   argv[0] &#x3D; NanNull();
</code></pre>
                <pre><code class="added">+   argv[0] &#x3D; Nan::Null();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; im_h &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; im_h &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="removed">-     if (args[0]-&gt;IsNumber() &amp;&amp; args[1]-&gt;IsNumber()) {
</code></pre>
                <pre><code class="added">+     if (info[0]-&gt;IsNumber() &amp;&amp; info[1]-&gt;IsNumber()) {
</code></pre>
                <pre><code class="removed">-       width &#x3D; args[0]-&gt;Uint32Value();
      height &#x3D; args[1]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+       width &#x3D; info[0]-&gt;Uint32Value();
      height &#x3D; info[1]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     } else if (args[0]-&gt;IsString()) {
      std::string filename &#x3D; std::string(*NanUtf8String(args[0]-&gt;ToString()));
</code></pre>
                <pre><code class="added">+     } else if (info[0]-&gt;IsString()) {
      std::string filename &#x3D; std::string(*Nan::Utf8String(info[0]-&gt;ToString()));
</code></pre>
                <pre><code class="removed">-     } else if (Buffer::HasInstance(args[0])) {
      uint8_t *buf &#x3D; (uint8_t *) Buffer::Data(args[0]-&gt;ToObject());
      unsigned len &#x3D; Buffer::Length(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     } else if (Buffer::HasInstance(info[0])) {
      uint8_t *buf &#x3D; (uint8_t *) Buffer::Data(info[0]-&gt;ToObject());
      unsigned len &#x3D; Buffer::Length(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-         argv[0] &#x3D; NanError(&quot;Error loading file&quot;);
</code></pre>
                <pre><code class="added">+         argv[0] &#x3D; Nan::Error(&quot;Error loading file&quot;);
</code></pre>
                <pre><code class="removed">-     argv[0] &#x3D; NanError(e.what());
    argv[1] &#x3D; NanNull();
</code></pre>
                <pre><code class="added">+     argv[0] &#x3D; Nan::Error(e.what());
    argv[1] &#x3D; Nan::Null();
</code></pre>
                <pre><code class="removed">-   cb-&gt;Call(NanGetCurrentContext()-&gt;Global(), 2, argv);
</code></pre>
                <pre><code class="added">+   cb-&gt;Call(Nan::GetCurrentContext()-&gt;Global(), 2, argv);
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/OpenCV.h</h3>
          <div class="diff">
                <pre><code class="removed">-   if (args.Length() &lt;&#x3D; (I) || !args[I]-&gt;IsFunction())                   \
    return NanThrowTypeError(&quot;Argument &quot; #I &quot; must be a function&quot;);  \
  Local&lt;Function&gt; VAR &#x3D; Local&lt;Function&gt;::Cast(args[I]);
</code></pre>
                <pre><code class="added">+   if (info.Length() &lt;&#x3D; (I) || !info[I]-&gt;IsFunction())                   \
    return Nan::ThrowTypeError(&quot;Argument &quot; #I &quot; must be a function&quot;);  \
  Local&lt;Function&gt; VAR &#x3D; Local&lt;Function&gt;::Cast(info[I]);
</code></pre>
                <pre><code class="removed">- 	NanScope();		\
	TYP *self &#x3D; ObjectWrap::Unwrap&lt;TYP&gt;(args.This());
</code></pre>
                <pre><code class="added">+ 	Nan::HandleScope scope;		\
	TYP *self &#x3D; Nan::ObjectWrap::Unwrap&lt;TYP&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanThrowTypeError( ERR );
</code></pre>
                <pre><code class="added">+   Nan::ThrowTypeError( ERR );
</code></pre>
                <pre><code class="removed">-   NanThrowError( ERR );
</code></pre>
                <pre><code class="added">+   Nan::ThrowError( ERR );
</code></pre>
                <pre><code class="removed">-   if (args[IND]-&gt;IsInt32()){ \
    NAME &#x3D; args[IND]-&gt;Uint32Value(); \
</code></pre>
                <pre><code class="added">+   if (info[IND]-&gt;IsInt32()){ \
    NAME &#x3D; info[IND]-&gt;Uint32Value(); \
</code></pre>
                <pre><code class="removed">-   if (args[IND]-&gt;IsInt32()){ \
    NAME &#x3D; args[IND]-&gt;NumberValue(); \
</code></pre>
                <pre><code class="added">+   if (info[IND]-&gt;IsInt32()){ \
    NAME &#x3D; info[IND]-&gt;NumberValue(); \
</code></pre>
                <pre><code class="removed">- class OpenCV: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class OpenCV: public Nan::ObjectWrap {
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Matrix.cc</h3>
          <div class="diff">
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; Matrix::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; Matrix::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(Matrix::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(Matrix::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;Matrix&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;Matrix&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;row&quot;, Row);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;col&quot;, Col);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;pixelRow&quot;, PixelRow);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;pixelCol&quot;, PixelCol);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;empty&quot;, Empty);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;get&quot;, Get);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;set&quot;, Set);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;put&quot;, Put);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;brightness&quot;, Brightness);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;normalize&quot;, Normalize);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;getData&quot;, GetData);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;pixel&quot;, Pixel);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;width&quot;, Width);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;height&quot;, Height);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;size&quot;, Size);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;clone&quot;, Clone);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;crop&quot;, Crop);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;toBuffer&quot;, ToBuffer);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;toBufferAsync&quot;, ToBufferAsync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;ellipse&quot;, Ellipse);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;rectangle&quot;, Rectangle);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;line&quot;, Line);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;fillPoly&quot;, FillPoly);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;save&quot;, Save);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;saveAsync&quot;, SaveAsync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;resize&quot;, Resize);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;rotate&quot;, Rotate);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;copyTo&quot;, CopyTo);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;pyrDown&quot;, PyrDown);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;pyrUp&quot;, PyrUp);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;channels&quot;, Channels);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;convertGrayscale&quot;, ConvertGrayscale);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;convertHSVscale&quot;, ConvertHSVscale);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;gaussianBlur&quot;, GaussianBlur);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;medianBlur&quot;, MedianBlur);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;bilateralFilter&quot;, BilateralFilter);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;copy&quot;, Copy);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;flip&quot;, Flip);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;roi&quot;, ROI);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;ptr&quot;, Ptr);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;absDiff&quot;, AbsDiff);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;addWeighted&quot;, AddWeighted);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;bitwiseXor&quot;, BitwiseXor);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;bitwiseNot&quot;, BitwiseNot);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;bitwiseAnd&quot;, BitwiseAnd);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;countNonZero&quot;, CountNonZero);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;canny&quot;, Canny);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;dilate&quot;, Dilate);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;erode&quot;, Erode);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;findContours&quot;, FindContours);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;drawContour&quot;, DrawContour);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;drawAllContours&quot;, DrawAllContours);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;goodFeaturesToTrack&quot;, GoodFeaturesToTrack);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;houghLinesP&quot;, HoughLinesP);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;crop&quot;, Crop);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;houghCircles&quot;, HoughCircles);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;inRange&quot;, inRange);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;adjustROI&quot;, AdjustROI);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;locateROI&quot;, LocateROI);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;threshold&quot;, Threshold);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;adaptiveThreshold&quot;, AdaptiveThreshold);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;meanStdDev&quot;, MeanStdDev);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;cvtColor&quot;, CvtColor);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;split&quot;, Split);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;merge&quot;, Merge);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;equalizeHist&quot;, EqualizeHist);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;floodFill&quot;, FloodFill);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;matchTemplate&quot;, MatchTemplate);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;templateMatches&quot;, TemplateMatches);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;minMaxLoc&quot;, MinMaxLoc);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;pushBack&quot;, PushBack);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;putText&quot;, PutText);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;getPerspectiveTransform&quot;, GetPerspectiveTransform);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;warpPerspective&quot;, WarpPerspective);
  NODE_SET_METHOD(ctor, &quot;Zeros&quot;, Zeros);
  NODE_SET_METHOD(ctor, &quot;Ones&quot;, Ones);
  NODE_SET_METHOD(ctor, &quot;Eye&quot;, Eye);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;copyWithMask&quot;, CopyWithMask);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;setWithMask&quot;, SetWithMask);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;meanWithMask&quot;, MeanWithMask);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;shift&quot;, Shift);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;release&quot;, Release);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;row&quot;, Row);
  Nan::SetPrototypeMethod(ctor, &quot;col&quot;, Col);
  Nan::SetPrototypeMethod(ctor, &quot;pixelRow&quot;, PixelRow);
  Nan::SetPrototypeMethod(ctor, &quot;pixelCol&quot;, PixelCol);
  Nan::SetPrototypeMethod(ctor, &quot;empty&quot;, Empty);
  Nan::SetPrototypeMethod(ctor, &quot;get&quot;, Get);
  Nan::SetPrototypeMethod(ctor, &quot;set&quot;, Set);
  Nan::SetPrototypeMethod(ctor, &quot;put&quot;, Put);
  Nan::SetPrototypeMethod(ctor, &quot;brightness&quot;, Brightness);
  Nan::SetPrototypeMethod(ctor, &quot;normalize&quot;, Normalize);
  Nan::SetPrototypeMethod(ctor, &quot;getData&quot;, GetData);
  Nan::SetPrototypeMethod(ctor, &quot;pixel&quot;, Pixel);
  Nan::SetPrototypeMethod(ctor, &quot;width&quot;, Width);
  Nan::SetPrototypeMethod(ctor, &quot;height&quot;, Height);
  Nan::SetPrototypeMethod(ctor, &quot;size&quot;, Size);
  Nan::SetPrototypeMethod(ctor, &quot;clone&quot;, Clone);
  Nan::SetPrototypeMethod(ctor, &quot;crop&quot;, Crop);
  Nan::SetPrototypeMethod(ctor, &quot;toBuffer&quot;, ToBuffer);
  Nan::SetPrototypeMethod(ctor, &quot;toBufferAsync&quot;, ToBufferAsync);
  Nan::SetPrototypeMethod(ctor, &quot;ellipse&quot;, Ellipse);
  Nan::SetPrototypeMethod(ctor, &quot;rectangle&quot;, Rectangle);
  Nan::SetPrototypeMethod(ctor, &quot;line&quot;, Line);
  Nan::SetPrototypeMethod(ctor, &quot;fillPoly&quot;, FillPoly);
  Nan::SetPrototypeMethod(ctor, &quot;save&quot;, Save);
  Nan::SetPrototypeMethod(ctor, &quot;saveAsync&quot;, SaveAsync);
  Nan::SetPrototypeMethod(ctor, &quot;resize&quot;, Resize);
  Nan::SetPrototypeMethod(ctor, &quot;rotate&quot;, Rotate);
  Nan::SetPrototypeMethod(ctor, &quot;copyTo&quot;, CopyTo);
  Nan::SetPrototypeMethod(ctor, &quot;pyrDown&quot;, PyrDown);
  Nan::SetPrototypeMethod(ctor, &quot;pyrUp&quot;, PyrUp);
  Nan::SetPrototypeMethod(ctor, &quot;channels&quot;, Channels);
  Nan::SetPrototypeMethod(ctor, &quot;convertGrayscale&quot;, ConvertGrayscale);
  Nan::SetPrototypeMethod(ctor, &quot;convertHSVscale&quot;, ConvertHSVscale);
  Nan::SetPrototypeMethod(ctor, &quot;gaussianBlur&quot;, GaussianBlur);
  Nan::SetPrototypeMethod(ctor, &quot;medianBlur&quot;, MedianBlur);
  Nan::SetPrototypeMethod(ctor, &quot;bilateralFilter&quot;, BilateralFilter);
  Nan::SetPrototypeMethod(ctor, &quot;copy&quot;, Copy);
  Nan::SetPrototypeMethod(ctor, &quot;flip&quot;, Flip);
  Nan::SetPrototypeMethod(ctor, &quot;roi&quot;, ROI);
  Nan::SetPrototypeMethod(ctor, &quot;ptr&quot;, Ptr);
  Nan::SetPrototypeMethod(ctor, &quot;absDiff&quot;, AbsDiff);
  Nan::SetPrototypeMethod(ctor, &quot;addWeighted&quot;, AddWeighted);
  Nan::SetPrototypeMethod(ctor, &quot;bitwiseXor&quot;, BitwiseXor);
  Nan::SetPrototypeMethod(ctor, &quot;bitwiseNot&quot;, BitwiseNot);
  Nan::SetPrototypeMethod(ctor, &quot;bitwiseAnd&quot;, BitwiseAnd);
  Nan::SetPrototypeMethod(ctor, &quot;countNonZero&quot;, CountNonZero);
  Nan::SetPrototypeMethod(ctor, &quot;canny&quot;, Canny);
  Nan::SetPrototypeMethod(ctor, &quot;dilate&quot;, Dilate);
  Nan::SetPrototypeMethod(ctor, &quot;erode&quot;, Erode);
  Nan::SetPrototypeMethod(ctor, &quot;findContours&quot;, FindContours);
  Nan::SetPrototypeMethod(ctor, &quot;drawContour&quot;, DrawContour);
  Nan::SetPrototypeMethod(ctor, &quot;drawAllContours&quot;, DrawAllContours);
  Nan::SetPrototypeMethod(ctor, &quot;goodFeaturesToTrack&quot;, GoodFeaturesToTrack);
  Nan::SetPrototypeMethod(ctor, &quot;houghLinesP&quot;, HoughLinesP);
  Nan::SetPrototypeMethod(ctor, &quot;crop&quot;, Crop);
  Nan::SetPrototypeMethod(ctor, &quot;houghCircles&quot;, HoughCircles);
  Nan::SetPrototypeMethod(ctor, &quot;inRange&quot;, inRange);
  Nan::SetPrototypeMethod(ctor, &quot;adjustROI&quot;, AdjustROI);
  Nan::SetPrototypeMethod(ctor, &quot;locateROI&quot;, LocateROI);
  Nan::SetPrototypeMethod(ctor, &quot;threshold&quot;, Threshold);
  Nan::SetPrototypeMethod(ctor, &quot;adaptiveThreshold&quot;, AdaptiveThreshold);
  Nan::SetPrototypeMethod(ctor, &quot;meanStdDev&quot;, MeanStdDev);
  Nan::SetPrototypeMethod(ctor, &quot;cvtColor&quot;, CvtColor);
  Nan::SetPrototypeMethod(ctor, &quot;split&quot;, Split);
  Nan::SetPrototypeMethod(ctor, &quot;merge&quot;, Merge);
  Nan::SetPrototypeMethod(ctor, &quot;equalizeHist&quot;, EqualizeHist);
  Nan::SetPrototypeMethod(ctor, &quot;floodFill&quot;, FloodFill);
  Nan::SetPrototypeMethod(ctor, &quot;matchTemplate&quot;, MatchTemplate);
  Nan::SetPrototypeMethod(ctor, &quot;templateMatches&quot;, TemplateMatches);
  Nan::SetPrototypeMethod(ctor, &quot;minMaxLoc&quot;, MinMaxLoc);
  Nan::SetPrototypeMethod(ctor, &quot;pushBack&quot;, PushBack);
  Nan::SetPrototypeMethod(ctor, &quot;putText&quot;, PutText);
  Nan::SetPrototypeMethod(ctor, &quot;getPerspectiveTransform&quot;, GetPerspectiveTransform);
  Nan::SetPrototypeMethod(ctor, &quot;warpPerspective&quot;, WarpPerspective);
  Nan::SetMethod(ctor, &quot;Zeros&quot;, Zeros);
  Nan::SetMethod(ctor, &quot;Ones&quot;, Ones);
  Nan::SetMethod(ctor, &quot;Eye&quot;, Eye);
  Nan::SetPrototypeMethod(ctor, &quot;copyWithMask&quot;, CopyWithMask);
  Nan::SetPrototypeMethod(ctor, &quot;setWithMask&quot;, SetWithMask);
  Nan::SetPrototypeMethod(ctor, &quot;meanWithMask&quot;, MeanWithMask);
  Nan::SetPrototypeMethod(ctor, &quot;shift&quot;, Shift);
  Nan::SetPrototypeMethod(ctor, &quot;release&quot;, Release);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;Matrix&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;Matrix&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
  if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    NanThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    Nan::ThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   } else if (args.Length() &#x3D;&#x3D; 2 &amp;&amp; args[0]-&gt;IsInt32() &amp;&amp; args[1]-&gt;IsInt32()) {
    mat &#x3D; new Matrix(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue());
  } else if (args.Length() &#x3D;&#x3D; 3 &amp;&amp; args[0]-&gt;IsInt32() &amp;&amp; args[1]-&gt;IsInt32()
      &amp;&amp; args[2]-&gt;IsInt32()) {
    mat &#x3D; new Matrix(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
        args[2]-&gt;IntegerValue());
  } else if (args.Length() &#x3D;&#x3D; 4 &amp;&amp; args[0]-&gt;IsInt32() &amp;&amp; args[1]-&gt;IsInt32() &amp;&amp;
        args[2]-&gt;IsInt32() &amp;&amp; args[3]-&gt;IsArray()) {
  } else {  // if (args.Length() &#x3D;&#x3D; 5) {
    Matrix *other &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
    int x &#x3D; args[1]-&gt;IntegerValue();
    int y &#x3D; args[2]-&gt;IntegerValue();
    int w &#x3D; args[3]-&gt;IntegerValue();
    int h &#x3D; args[4]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   } else if (info.Length() &#x3D;&#x3D; 2 &amp;&amp; info[0]-&gt;IsInt32() &amp;&amp; info[1]-&gt;IsInt32()) {
    mat &#x3D; new Matrix(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue());
  } else if (info.Length() &#x3D;&#x3D; 3 &amp;&amp; info[0]-&gt;IsInt32() &amp;&amp; info[1]-&gt;IsInt32()
      &amp;&amp; info[2]-&gt;IsInt32()) {
    mat &#x3D; new Matrix(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
        info[2]-&gt;IntegerValue());
  } else if (info.Length() &#x3D;&#x3D; 4 &amp;&amp; info[0]-&gt;IsInt32() &amp;&amp; info[1]-&gt;IsInt32() &amp;&amp;
        info[2]-&gt;IsInt32() &amp;&amp; info[3]-&gt;IsArray()) {
  } else {  // if (info.Length() &#x3D;&#x3D; 5) {
    Matrix *other &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
    int x &#x3D; info[1]-&gt;IntegerValue();
    int y &#x3D; info[2]-&gt;IntegerValue();
    int w &#x3D; info[3]-&gt;IntegerValue();
    int h &#x3D; info[4]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   mat-&gt;Wrap(args.Holder());
  NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   mat-&gt;Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
                <pre><code class="removed">-     NanThrowError(&quot;Only 1-3 channels are supported&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(&quot;Only 1-3 channels are supported&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Boolean&gt;(self-&gt;mat.empty()));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Boolean&gt;(self-&gt;mat.empty()));
</code></pre>
                <pre><code class="removed">-   int y &#x3D; args[0]-&gt;IntegerValue();
  int x &#x3D; args[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int y &#x3D; info[0]-&gt;IntegerValue();
  int x &#x3D; info[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 3) {
    Local &lt; Object &gt; objColor &#x3D; args[2]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 3) {
    Local &lt; Object &gt; objColor &#x3D; info[2]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     NanReturnValue(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-       v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;v8::Array&gt;(3);
      arr-&gt;Set(0, NanNew&lt;Number&gt;(intensity[0]));
      arr-&gt;Set(1, NanNew&lt;Number&gt;(intensity[1]));
      arr-&gt;Set(2, NanNew&lt;Number&gt;(intensity[2]));
      NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+       v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;v8::Array&gt;(3);
      arr-&gt;Set(0, Nan::New&lt;Number&gt;(intensity[0]));
      arr-&gt;Set(1, Nan::New&lt;Number&gt;(intensity[1]));
      arr-&gt;Set(2, Nan::New&lt;Number&gt;(intensity[2]));
      info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-       NanReturnValue(NanNew&lt;Number&gt;(intensity));
</code></pre>
                <pre><code class="added">+       info.GetReturnValue().Set(Nan::New&lt;Number&gt;(intensity));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   // NanReturnValue(NanNew&lt;Number&gt;(val));
</code></pre>
                <pre><code class="added">+   // info.GetReturnValue().Set(Nan::New&lt;Number&gt;(val));
</code></pre>
                <pre><code class="removed">-   int i &#x3D; args[0]-&gt;IntegerValue();
  int j &#x3D; args[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int i &#x3D; info[0]-&gt;IntegerValue();
  int j &#x3D; info[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(val));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(val));
</code></pre>
                <pre><code class="removed">-   int i &#x3D; args[0]-&gt;IntegerValue();
  int j &#x3D; args[1]-&gt;IntegerValue();
  double val &#x3D; args[2]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   int i &#x3D; info[0]-&gt;IntegerValue();
  int j &#x3D; info[1]-&gt;IntegerValue();
  double val &#x3D; info[2]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 4) {
    self-&gt;mat.at&lt;cv::Vec3b&gt;(i, j)[args[3]-&gt;NumberValue()] &#x3D; val;
  } else if (args.Length() &#x3D;&#x3D; 3) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 4) {
    self-&gt;mat.at&lt;cv::Vec3b&gt;(i, j)[info[3]-&gt;NumberValue()] &#x3D; val;
  } else if (info.Length() &#x3D;&#x3D; 3) {
</code></pre>
                <pre><code class="removed">-     NanThrowTypeError(&quot;Invalid number of arguments&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowTypeError(&quot;Invalid number of arguments&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   if (!Buffer::HasInstance(args[0])) {
    NanThrowTypeError(&quot;Not a buffer&quot;);
</code></pre>
                <pre><code class="added">+   if (!Buffer::HasInstance(info[0])) {
    Nan::ThrowTypeError(&quot;Not a buffer&quot;);
</code></pre>
                <pre><code class="removed">-   const char* buffer_data &#x3D; Buffer::Data(args[0]);
  size_t buffer_length &#x3D; Buffer::Length(args[0]);
</code></pre>
                <pre><code class="added">+   const char* buffer_data &#x3D; Buffer::Data(info[0]);
  size_t buffer_length &#x3D; Buffer::Length(info[0]);
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; buf &#x3D; NanNewBufferHandle(size);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; buf &#x3D; Nan::NewBuffer(size).ToLocalChecked();
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Object&gt; globalObj &#x3D; NanGetCurrentContext()-&gt;Global();
  v8::Local&lt;v8::Function&gt; bufferConstructor &#x3D; v8::Local&lt;v8::Function&gt;::Cast(globalObj-&gt;Get(NanNew&lt;String&gt;(&quot;Buffer&quot;)));
  v8::Handle&lt;v8::Value&gt; constructorArgs[3] &#x3D; {buf, NanNew&lt;v8::Integer&gt;((unsigned) size), NanNew&lt;v8::Integer&gt;(0)};
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Object&gt; globalObj &#x3D; Nan::GetCurrentContext()-&gt;Global();
  v8::Local&lt;v8::Function&gt; bufferConstructor &#x3D; v8::Local&lt;v8::Function&gt;::Cast(globalObj-&gt;Get(Nan::New&lt;String&gt;(&quot;Buffer&quot;).ToLocalChecked()));
  v8::Handle&lt;v8::Value&gt; constructorArgs[3] &#x3D; {buf, Nan::New&lt;v8::Integer&gt;((unsigned) size), Nan::New&lt;v8::Integer&gt;(0)};
</code></pre>
                <pre><code class="removed">-   NanReturnValue(actualBuffer);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(actualBuffer);
</code></pre>
                <pre><code class="removed">-   NanScope();
  Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 2) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 2) {
</code></pre>
                <pre><code class="removed">-       NanThrowError(&quot;those channels are not supported&quot;);
</code></pre>
                <pre><code class="added">+       Nan::ThrowError(&quot;those channels are not supported&quot;);
</code></pre>
                <pre><code class="removed">-     double alpha &#x3D; args[0]-&gt;NumberValue();
    int beta &#x3D; args[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     double alpha &#x3D; info[0]-&gt;NumberValue();
    int beta &#x3D; info[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-     if (args.Length() &#x3D;&#x3D; 1) {
      int diff &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     if (info.Length() &#x3D;&#x3D; 1) {
      int diff &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-       NanReturnValue(NanNew(&quot;Insufficient or wrong arguments&quot;));
</code></pre>
                <pre><code class="added">+       info.GetReturnValue().Set(Nan::New(&quot;Insufficient or wrong arguments&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   if (!args[0]-&gt;IsNumber()) {
    NanThrowTypeError(&quot;min is required (argument 1)&quot;);
</code></pre>
                <pre><code class="added">+   if (!info[0]-&gt;IsNumber()) {
    Nan::ThrowTypeError(&quot;min is required (argument 1)&quot;);
</code></pre>
                <pre><code class="removed">-   if (!args[1]-&gt;IsNumber()) {
    NanThrowTypeError(&quot;max is required (argument 2)&quot;);
</code></pre>
                <pre><code class="added">+   if (!info[1]-&gt;IsNumber()) {
    Nan::ThrowTypeError(&quot;max is required (argument 2)&quot;);
</code></pre>
                <pre><code class="removed">-   if (args[2]-&gt;IsNumber()) {
    type &#x3D; args[2]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   if (info[2]-&gt;IsNumber()) {
    type &#x3D; info[2]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-       NanThrowTypeError(&quot;type value must be NORM_INF&#x3D;1, NORM_L1&#x3D;2, NORM_L2&#x3D;4,&quot;
</code></pre>
                <pre><code class="added">+       Nan::ThrowTypeError(&quot;type value must be NORM_INF&#x3D;1, NORM_L1&#x3D;2, NORM_L2&#x3D;4,&quot;
</code></pre>
                <pre><code class="removed">-   if (args[3]-&gt;IsNumber()) {
    dtype &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info[3]-&gt;IsNumber()) {
    dtype &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   double min &#x3D; args[0]-&gt;NumberValue();
  double max &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   double min &#x3D; info[0]-&gt;NumberValue();
  double max &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if (args[4]-&gt;IsObject()) {
    Matrix *mmask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[4]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   if (info[4]-&gt;IsObject()) {
    Matrix *mmask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[4]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(2);
  arr-&gt;Set(0, NanNew&lt;Number&gt;(self-&gt;mat.size().height));
  arr-&gt;Set(1, NanNew&lt;Number&gt;(self-&gt;mat.size().width));
</code></pre>
                <pre><code class="added">+   v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(2);
  arr-&gt;Set(0, Nan::New&lt;Number&gt;(self-&gt;mat.size().height));
  arr-&gt;Set(1, Nan::New&lt;Number&gt;(self-&gt;mat.size().width));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-       NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="added">+       Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
</code></pre>
                <pre><code class="removed">-   Matrix *m &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="added">+   Matrix *m &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(im_h);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(im_h);
</code></pre>
                <pre><code class="removed">-   if ((args.Length() &#x3D;&#x3D; 4) &amp;&amp; (args[0]-&gt;IsNumber()) &amp;&amp; (args[1]-&gt;IsNumber())
      &amp;&amp; (args[2]-&gt;IsNumber()) &amp;&amp; (args[3]-&gt;IsNumber())) {
</code></pre>
                <pre><code class="added">+   if ((info.Length() &#x3D;&#x3D; 4) &amp;&amp; (info[0]-&gt;IsNumber()) &amp;&amp; (info[1]-&gt;IsNumber())
      &amp;&amp; (info[2]-&gt;IsNumber()) &amp;&amp; (info[3]-&gt;IsNumber())) {
</code></pre>
                <pre><code class="removed">-     int x &#x3D; args[0]-&gt;IntegerValue();
    int y &#x3D; args[1]-&gt;IntegerValue();
    int width &#x3D; args[2]-&gt;IntegerValue();
    int height &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     int x &#x3D; info[0]-&gt;IntegerValue();
    int y &#x3D; info[1]-&gt;IntegerValue();
    int width &#x3D; info[2]-&gt;IntegerValue();
    int height &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-         NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *m &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="added">+         Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *m &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(im_h);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(im_h);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(NanNew(&quot;Insufficient or wrong arguments&quot;));
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(Nan::New(&quot;Insufficient or wrong arguments&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   int y &#x3D; args[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(width);
</code></pre>
                <pre><code class="added">+   int y &#x3D; info[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(width);
</code></pre>
                <pre><code class="removed">-     arr-&gt;Set(x, NanNew&lt;Number&gt;(v));
</code></pre>
                <pre><code class="added">+     arr-&gt;Set(x, Nan::New&lt;Number&gt;(v));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   int y &#x3D; args[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(width * 3);
</code></pre>
                <pre><code class="added">+   int y &#x3D; info[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(width * 3);
</code></pre>
                <pre><code class="removed">-     arr-&gt;Set(offset, NanNew&lt;Number&gt;((double) pixel.val[0]));
    arr-&gt;Set(offset + 1, NanNew&lt;Number&gt;((double) pixel.val[1]));
    arr-&gt;Set(offset + 2, NanNew&lt;Number&gt;((double) pixel.val[2]));
</code></pre>
                <pre><code class="added">+     arr-&gt;Set(offset, Nan::New&lt;Number&gt;((double) pixel.val[0]));
    arr-&gt;Set(offset + 1, Nan::New&lt;Number&gt;((double) pixel.val[1]));
    arr-&gt;Set(offset + 2, Nan::New&lt;Number&gt;((double) pixel.val[2]));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(height);
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(height);
</code></pre>
                <pre><code class="removed">-     arr-&gt;Set(y, NanNew&lt;Number&gt;(v));
</code></pre>
                <pre><code class="added">+     arr-&gt;Set(y, Nan::New&lt;Number&gt;(v));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(height * 3);
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[0]-&gt;IntegerValue();
  v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(height * 3);
</code></pre>
                <pre><code class="removed">-     arr-&gt;Set(offset, NanNew&lt;Number&gt;((double) pixel.val[0]));
    arr-&gt;Set(offset + 1, NanNew&lt;Number&gt;((double) pixel.val[1]));
    arr-&gt;Set(offset + 2, NanNew&lt;Number&gt;((double) pixel.val[2]));
</code></pre>
                <pre><code class="added">+     arr-&gt;Set(offset, Nan::New&lt;Number&gt;((double) pixel.val[0]));
    arr-&gt;Set(offset + 1, Nan::New&lt;Number&gt;((double) pixel.val[1]));
    arr-&gt;Set(offset + 2, Nan::New&lt;Number&gt;((double) pixel.val[2]));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(self-&gt;mat.size().width));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(self-&gt;mat.size().width));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(self-&gt;mat.size().height));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(self-&gt;mat.size().height));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(self-&gt;mat.channels()));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(self-&gt;mat.channels()));
</code></pre>
                <pre><code class="removed">-   if ((args.Length() &gt; 0) &amp;&amp; (args[0]-&gt;IsFunction())) {
    return Matrix::ToBufferAsync(args);
</code></pre>
                <pre><code class="added">+   if ((info.Length() &gt; 0) &amp;&amp; (info[0]-&gt;IsFunction())) {
    return Matrix::ToBufferAsync(info);
</code></pre>
                <pre><code class="removed">-   if ((args.Length() &gt; 0) &amp;&amp; (args[0]-&gt;IsObject())) {
</code></pre>
                <pre><code class="added">+   if ((info.Length() &gt; 0) &amp;&amp; (info[0]-&gt;IsObject())) {
</code></pre>
                <pre><code class="removed">-     v8::Handle &lt; v8::Object &gt; options &#x3D; v8::Handle&lt;v8::Object&gt;::Cast(args[0]);
</code></pre>
                <pre><code class="added">+     v8::Handle &lt; v8::Object &gt; options &#x3D; v8::Handle&lt;v8::Object&gt;::Cast(info[0]);
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;ext&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;ext&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;ext&quot;))-&gt;ToString());
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;ext&quot;).ToLocalChecked())-&gt;ToString());
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;jpegQuality&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;jpegQuality&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;jpegQuality&quot;))-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;jpegQuality&quot;).ToLocalChecked())-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;pngCompression&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;pngCompression&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;pngCompression&quot;))-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;pngCompression&quot;).ToLocalChecked())-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   Local &lt; Object &gt; buf &#x3D; NanNewBufferHandle(vec.size());
</code></pre>
                <pre><code class="added">+   Local &lt; Object &gt; buf &#x3D; Nan::NewBuffer(vec.size()).ToLocalChecked();
</code></pre>
                <pre><code class="removed">-   v8::Local &lt; v8::Object &gt; globalObj &#x3D; NanGetCurrentContext()-&gt;Global();
</code></pre>
                <pre><code class="added">+   v8::Local &lt; v8::Object &gt; globalObj &#x3D; Nan::GetCurrentContext()-&gt;Global();
</code></pre>
                <pre><code class="removed">-       &gt; ::Cast(globalObj-&gt;Get(NanNew&lt;String&gt;(&quot;Buffer&quot;)));
</code></pre>
                <pre><code class="added">+       &gt; ::Cast(globalObj-&gt;Get(Nan::New&lt;String&gt;(&quot;Buffer&quot;).ToLocalChecked()));
</code></pre>
                <pre><code class="removed">-       {buf, NanNew&lt;v8::Integer&gt;((unsigned)vec.size()), NanNew&lt;v8::Integer&gt;(0)};
</code></pre>
                <pre><code class="added">+       {buf, Nan::New&lt;v8::Integer&gt;((unsigned)vec.size()), Nan::New&lt;v8::Integer&gt;(0)};
</code></pre>
                <pre><code class="removed">-   NanReturnValue(actualBuffer);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(actualBuffer);
</code></pre>
                <pre><code class="removed">- class AsyncToBufferWorker: public NanAsyncWorker {
</code></pre>
                <pre><code class="added">+ class AsyncToBufferWorker: public Nan::AsyncWorker {
</code></pre>
                <pre><code class="removed">-   AsyncToBufferWorker(NanCallback *callback, Matrix* matrix, string ext,
</code></pre>
                <pre><code class="added">+   AsyncToBufferWorker(Nan::Callback *callback, Matrix* matrix, string ext,
</code></pre>
                <pre><code class="removed">-       NanAsyncWorker(callback),
</code></pre>
                <pre><code class="added">+       Nan::AsyncWorker(callback),
</code></pre>
                <pre><code class="removed">-     NanScope();
</code></pre>
                <pre><code class="added">+     Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; buf &#x3D; NanNewBufferHandle(res.size());
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; buf &#x3D; Nan::NewBuffer(res.size()).ToLocalChecked();
</code></pre>
                <pre><code class="removed">-     v8::Local&lt;v8::Object&gt; globalObj &#x3D; NanGetCurrentContext()-&gt;Global();
    v8::Local&lt;v8::Function&gt; bufferConstructor &#x3D; v8::Local&lt;v8::Function&gt;::Cast(globalObj-&gt;Get(NanNew&lt;String&gt;(&quot;Buffer&quot;)));
    v8::Handle&lt;v8::Value&gt; constructorArgs[3] &#x3D; {buf, NanNew&lt;v8::Integer&gt;((unsigned)res.size()), NanNew&lt;v8::Integer&gt;(0)};
</code></pre>
                <pre><code class="added">+     v8::Local&lt;v8::Object&gt; globalObj &#x3D; Nan::GetCurrentContext()-&gt;Global();
    v8::Local&lt;v8::Function&gt; bufferConstructor &#x3D; v8::Local&lt;v8::Function&gt;::Cast(globalObj-&gt;Get(Nan::New&lt;String&gt;(&quot;Buffer&quot;).ToLocalChecked()));
    v8::Handle&lt;v8::Value&gt; constructorArgs[3] &#x3D; {buf, Nan::New&lt;v8::Integer&gt;((unsigned)res.size()), Nan::New&lt;v8::Integer&gt;(0)};
</code></pre>
                <pre><code class="removed">-       NanNull(),
</code></pre>
                <pre><code class="added">+       Nan::Null(),
</code></pre>
                <pre><code class="removed">-   if ((args.Length() &gt; 1) &amp;&amp; (args[1]-&gt;IsObject())) {
</code></pre>
                <pre><code class="added">+   if ((info.Length() &gt; 1) &amp;&amp; (info[1]-&gt;IsObject())) {
</code></pre>
                <pre><code class="removed">-     v8::Handle &lt; v8::Object &gt; options &#x3D; v8::Handle&lt;v8::Object&gt;::Cast(args[1]);
</code></pre>
                <pre><code class="added">+     v8::Handle &lt; v8::Object &gt; options &#x3D; v8::Handle&lt;v8::Object&gt;::Cast(info[1]);
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;ext&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;ext&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;ext&quot;))-&gt;ToString());
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;ext&quot;).ToLocalChecked())-&gt;ToString());
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;jpegQuality&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;jpegQuality&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;jpegQuality&quot;))-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;jpegQuality&quot;).ToLocalChecked())-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;pngCompression&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;pngCompression&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;pngCompression&quot;))-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;pngCompression&quot;).ToLocalChecked())-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
  NanAsyncQueueWorker(new AsyncToBufferWorker(callback, self, ext, params));
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
  Nan::AsyncQueueWorker(new AsyncToBufferWorker(callback, self, ext, params));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsObject()) {
    v8::Handle &lt; v8::Object &gt; options &#x3D; v8::Handle&lt;v8::Object&gt;::Cast(args[0]);
    if (options-&gt;Has(NanNew&lt;String&gt;(&quot;center&quot;))) {
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsObject()) {
    v8::Handle &lt; v8::Object &gt; options &#x3D; v8::Handle&lt;v8::Object&gt;::Cast(info[0]);
    if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;center&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;center&quot;))-&gt;ToObject();
      x &#x3D; center-&gt;Get(NanNew&lt;String&gt;(&quot;x&quot;))-&gt;Uint32Value();
      y &#x3D; center-&gt;Get(NanNew&lt;String&gt;(&quot;y&quot;))-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;center&quot;).ToLocalChecked())-&gt;ToObject();
      x &#x3D; center-&gt;Get(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked())-&gt;Uint32Value();
      y &#x3D; center-&gt;Get(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked())-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;axes&quot;))) {
      Local &lt; Object &gt; axes &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;axes&quot;))-&gt;ToObject();
      width &#x3D; axes-&gt;Get(NanNew&lt;String&gt;(&quot;width&quot;))-&gt;Uint32Value();
      height &#x3D; axes-&gt;Get(NanNew&lt;String&gt;(&quot;height&quot;))-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;axes&quot;).ToLocalChecked())) {
      Local &lt; Object &gt; axes &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;axes&quot;).ToLocalChecked())-&gt;ToObject();
      width &#x3D; axes-&gt;Get(Nan::New&lt;String&gt;(&quot;width&quot;).ToLocalChecked())-&gt;Uint32Value();
      height &#x3D; axes-&gt;Get(Nan::New&lt;String&gt;(&quot;height&quot;).ToLocalChecked())-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;thickness&quot;))) {
      thickness &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;thickness&quot;))-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;thickness&quot;).ToLocalChecked())) {
      thickness &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;thickness&quot;).ToLocalChecked())-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;angle&quot;))) {
      angle &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;angle&quot;))-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;angle&quot;).ToLocalChecked())) {
      angle &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;angle&quot;).ToLocalChecked())-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;startAngle&quot;))) {
      startAngle &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;startAngle&quot;))-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;startAngle&quot;).ToLocalChecked())) {
      startAngle &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;startAngle&quot;).ToLocalChecked())-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;endAngle&quot;))) {
      endAngle &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;endAngle&quot;))-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;endAngle&quot;).ToLocalChecked())) {
      endAngle &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;endAngle&quot;).ToLocalChecked())-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;lineType&quot;))) {
      lineType &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;lineType&quot;))-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;lineType&quot;).ToLocalChecked())) {
      lineType &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;lineType&quot;).ToLocalChecked())-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;shift&quot;))) {
      shift &#x3D; options-&gt;Get(NanNew&lt;String&gt;(&quot;shift&quot;))-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;shift&quot;).ToLocalChecked())) {
      shift &#x3D; options-&gt;Get(Nan::New&lt;String&gt;(&quot;shift&quot;).ToLocalChecked())-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     if (options-&gt;Has(NanNew&lt;String&gt;(&quot;color&quot;))) {
</code></pre>
                <pre><code class="added">+     if (options-&gt;Has(Nan::New&lt;String&gt;(&quot;color&quot;).ToLocalChecked())) {
</code></pre>
                <pre><code class="removed">-           options-&gt;Get(NanNew&lt;String&gt;(&quot;color&quot;))-&gt;ToObject();
</code></pre>
                <pre><code class="added">+           options-&gt;Get(Nan::New&lt;String&gt;(&quot;color&quot;).ToLocalChecked())-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     x &#x3D; args[0]-&gt;Uint32Value();
    y &#x3D; args[1]-&gt;Uint32Value();
    width &#x3D; args[2]-&gt;Uint32Value();
    height &#x3D; args[3]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+     x &#x3D; info[0]-&gt;Uint32Value();
    y &#x3D; info[1]-&gt;Uint32Value();
    width &#x3D; info[2]-&gt;Uint32Value();
    height &#x3D; info[3]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-     if (args[4]-&gt;IsArray()) {
      Local &lt; Object &gt; objColor &#x3D; args[4]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+     if (info[4]-&gt;IsArray()) {
      Local &lt; Object &gt; objColor &#x3D; info[4]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     if (args[5]-&gt;IntegerValue())
      thickness &#x3D; args[5]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     if (info[5]-&gt;IntegerValue())
      thickness &#x3D; info[5]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsArray() &amp;&amp; args[1]-&gt;IsArray()) {
    Local &lt; Object &gt; xy &#x3D; args[0]-&gt;ToObject();
    Local &lt; Object &gt; width_height &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsArray() &amp;&amp; info[1]-&gt;IsArray()) {
    Local &lt; Object &gt; xy &#x3D; info[0]-&gt;ToObject();
    Local &lt; Object &gt; width_height &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     if (args[2]-&gt;IsArray()) {
      Local &lt; Object &gt; objColor &#x3D; args[2]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+     if (info[2]-&gt;IsArray()) {
      Local &lt; Object &gt; objColor &#x3D; info[2]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     if (args[3]-&gt;IntegerValue())
      thickness &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     if (info[3]-&gt;IntegerValue())
      thickness &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsArray() &amp;&amp; args[1]-&gt;IsArray()) {
    Local &lt; Object &gt; xy1 &#x3D; args[0]-&gt;ToObject();
    Local &lt; Object &gt; xy2 &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsArray() &amp;&amp; info[1]-&gt;IsArray()) {
    Local &lt; Object &gt; xy1 &#x3D; info[0]-&gt;ToObject();
    Local &lt; Object &gt; xy2 &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     if (args[2]-&gt;IsArray()) {
      Local &lt; Object &gt; objColor &#x3D; args[2]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+     if (info[2]-&gt;IsArray()) {
      Local &lt; Object &gt; objColor &#x3D; info[2]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-     if (args[3]-&gt;IntegerValue())
      thickness &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     if (info[3]-&gt;IntegerValue())
      thickness &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsArray()) {
    Local &lt; Array &gt; polyArray &#x3D; Local &lt; Array &gt; ::Cast(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsArray()) {
    Local &lt; Array &gt; polyArray &#x3D; Local &lt; Array &gt; ::Cast(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     if (args[1]-&gt;IsArray()) {
      Local&lt;Object&gt; objColor &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+     if (info[1]-&gt;IsArray()) {
      Local&lt;Object&gt; objColor &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 1) {
    return SaveAsync(args);
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 1) {
    return SaveAsync(info);
</code></pre>
                <pre><code class="removed">-   if (!args[0]-&gt;IsString()) {
    NanThrowTypeError(&quot;filename required&quot;);
</code></pre>
                <pre><code class="added">+   if (!info[0]-&gt;IsString()) {
    Nan::ThrowTypeError(&quot;filename required&quot;);
</code></pre>
                <pre><code class="removed">-   NanAsciiString filename(args[0]);
</code></pre>
                <pre><code class="added">+   Nan::Utf8String filename(info[0]);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(res));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(res));
</code></pre>
                <pre><code class="removed">- class AsyncSaveWorker: public NanAsyncWorker {
</code></pre>
                <pre><code class="added">+ class AsyncSaveWorker: public Nan::AsyncWorker {
</code></pre>
                <pre><code class="removed">-   AsyncSaveWorker(NanCallback *callback, Matrix* matrix, char* filename) :
      NanAsyncWorker(callback),
</code></pre>
                <pre><code class="added">+   AsyncSaveWorker(Nan::Callback *callback, Matrix* matrix, char* filename) :
      Nan::AsyncWorker(callback),
</code></pre>
                <pre><code class="removed">-     NanScope();
</code></pre>
                <pre><code class="added">+     Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-       NanNull(),
      NanNew&lt;Number&gt;(res)
</code></pre>
                <pre><code class="added">+       Nan::Null(),
      Nan::New&lt;Number&gt;(res)
</code></pre>
                <pre><code class="removed">-   if (!args[0]-&gt;IsString()) {
    NanThrowTypeError(&quot;filename required&quot;);
</code></pre>
                <pre><code class="added">+   if (!info[0]-&gt;IsString()) {
    Nan::ThrowTypeError(&quot;filename required&quot;);
</code></pre>
                <pre><code class="removed">-   NanAsciiString filename(args[0]);
</code></pre>
                <pre><code class="added">+   Nan::Utf8String filename(info[0]);
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
  NanAsyncQueueWorker(new AsyncSaveWorker(callback, self, *filename));
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
  Nan::AsyncQueueWorker(new AsyncSaveWorker(callback, self, *filename));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   int w &#x3D; args[0]-&gt;Uint32Value();
  int h &#x3D; args[1]-&gt;Uint32Value();
  int type &#x3D; (args.Length() &gt; 2) ? args[2]-&gt;IntegerValue() : CV_64FC1;
</code></pre>
                <pre><code class="added">+   int w &#x3D; info[0]-&gt;Uint32Value();
  int h &#x3D; info[1]-&gt;Uint32Value();
  int type &#x3D; (info.Length() &gt; 2) ? info[2]-&gt;IntegerValue() : CV_64FC1;
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; im_h &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; im_h &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(im_h);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(im_h);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   int w &#x3D; args[0]-&gt;Uint32Value();
  int h &#x3D; args[1]-&gt;Uint32Value();
  int type &#x3D; (args.Length() &gt; 2) ? args[2]-&gt;IntegerValue() : CV_64FC1;
</code></pre>
                <pre><code class="added">+   int w &#x3D; info[0]-&gt;Uint32Value();
  int h &#x3D; info[1]-&gt;Uint32Value();
  int type &#x3D; (info.Length() &gt; 2) ? info[2]-&gt;IntegerValue() : CV_64FC1;
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; im_h &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; im_h &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(im_h);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(im_h);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   int w &#x3D; args[0]-&gt;Uint32Value();
  int h &#x3D; args[1]-&gt;Uint32Value();
  int type &#x3D; (args.Length() &gt; 2) ? args[2]-&gt;IntegerValue() : CV_64FC1;
</code></pre>
                <pre><code class="added">+   int w &#x3D; info[0]-&gt;Uint32Value();
  int h &#x3D; info[1]-&gt;Uint32Value();
  int type &#x3D; (info.Length() &gt; 2) ? info[2]-&gt;IntegerValue() : CV_64FC1;
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; im_h &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; im_h &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_h);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(im_h);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(im_h);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-     NanThrowError(&quot;Image is no 3-channel&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(&quot;Image is no 3-channel&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-     NanThrowError(&quot;Image is no 3-channel&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(&quot;Image is no 3-channel&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if (args.Length() &lt; 1) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &lt; 1) {
</code></pre>
                <pre><code class="removed">-     if (!args[0]-&gt;IsArray()) {
      NanThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a 2 double array&quot;);
</code></pre>
                <pre><code class="added">+     if (!info[0]-&gt;IsArray()) {
      Nan::ThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a 2 double array&quot;);
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; array &#x3D; args[0]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; array &#x3D; info[0]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-       NanThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a 2 double array&quot;);
</code></pre>
                <pre><code class="added">+       Nan::ThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a 2 double array&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsNumber()) {
    ksize &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsNumber()) {
    ksize &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-       NanThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a positive odd integer&quot;);
</code></pre>
                <pre><code class="added">+       Nan::ThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a positive odd integer&quot;);
</code></pre>
                <pre><code class="removed">-     NanThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a positive odd integer&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowTypeError(&quot;&#x27;ksize&#x27; argument must be a positive odd integer&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if (args.Length() !&#x3D; 0) {
    if (args.Length() &lt; 3 || args.Length() &gt; 4) {
      NanThrowTypeError(&quot;BilateralFilter takes 0, 3, or 4 arguments&quot;);
</code></pre>
                <pre><code class="added">+   if (info.Length() !&#x3D; 0) {
    if (info.Length() &lt; 3 || info.Length() &gt; 4) {
      Nan::ThrowTypeError(&quot;BilateralFilter takes 0, 3, or 4 arguments&quot;);
</code></pre>
                <pre><code class="removed">-       d &#x3D; args[0]-&gt;IntegerValue();
      sigmaColor &#x3D; args[1]-&gt;NumberValue();
      sigmaSpace &#x3D; args[2]-&gt;NumberValue();
      if (args.Length() &#x3D;&#x3D; 4) {
        borderType &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+       d &#x3D; info[0]-&gt;IntegerValue();
      sigmaColor &#x3D; info[1]-&gt;NumberValue();
      sigmaSpace &#x3D; info[2]-&gt;NumberValue();
      if (info.Length() &#x3D;&#x3D; 4) {
        borderType &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-       NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="added">+       Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(img_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if ( args.Length() &lt; 1 || !args[0]-&gt;IsInt32() ) {
    NanThrowTypeError(&quot;Flip requires an integer flipCode argument &quot;
</code></pre>
                <pre><code class="added">+   if ( info.Length() &lt; 1 || !info[0]-&gt;IsInt32() ) {
    Nan::ThrowTypeError(&quot;Flip requires an integer flipCode argument &quot;
</code></pre>
                <pre><code class="removed">-   int flipCode &#x3D; args[0]-&gt;ToInt32()-&gt;Value();
</code></pre>
                <pre><code class="added">+   int flipCode &#x3D; info[0]-&gt;ToInt32()-&gt;Value();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; img_to_return &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; img_to_return &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(img_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if ( args.Length() !&#x3D; 4 ) {
    NanThrowTypeError(&quot;ROI requires x,y,w,h arguments&quot;);
</code></pre>
                <pre><code class="added">+   if ( info.Length() !&#x3D; 4 ) {
    Nan::ThrowTypeError(&quot;ROI requires x,y,w,h arguments&quot;);
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; img_to_return &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; img_to_return &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[0]-&gt;IntegerValue();
  int y &#x3D; args[1]-&gt;IntegerValue();
  int w &#x3D; args[2]-&gt;IntegerValue();
  int h &#x3D; args[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[0]-&gt;IntegerValue();
  int y &#x3D; info[1]-&gt;IntegerValue();
  int w &#x3D; info[2]-&gt;IntegerValue();
  int h &#x3D; info[3]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(img_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanScope();
  Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  int line &#x3D; args[0]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  int line &#x3D; info[0]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; return_buffer &#x3D; NanNewBufferHandle((char*)data, self-&gt;mat.step);
  NanReturnValue( return_buffer );
//  NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; return_buffer &#x3D; Nan::NewBuffer((char*)data, self-&gt;mat.step).ToLocalChecked();
  info.GetReturnValue().Set( return_buffer );
//  return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Matrix *src1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
  Matrix *src2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Matrix *src1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
  Matrix *src2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Matrix *src1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
  Matrix *src2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Matrix *src1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
  Matrix *src2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   float alpha &#x3D; args[1]-&gt;NumberValue();
  float beta &#x3D; args[3]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   float alpha &#x3D; info[1]-&gt;NumberValue();
  float beta &#x3D; info[3]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Matrix *src1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
  Matrix *src2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Matrix *src1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
  Matrix *src2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 3) {
    Matrix *mask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 3) {
    Matrix *mask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Matrix *dst &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
  if (args.Length() &#x3D;&#x3D; 2) {
    Matrix *mask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Matrix *dst &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
  if (info.Length() &#x3D;&#x3D; 2) {
    Matrix *mask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Matrix *src1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
  Matrix *src2 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
  if (args.Length() &#x3D;&#x3D; 3) {
    Matrix *mask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[2]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Matrix *src1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
  Matrix *src2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
  if (info.Length() &#x3D;&#x3D; 3) {
    Matrix *mask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[2]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(count));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(count));
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   //Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   //Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  int lowThresh &#x3D; args[0]-&gt;NumberValue();
  int highThresh &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  int lowThresh &#x3D; info[0]-&gt;NumberValue();
  int highThresh &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  int niters &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  int niters &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  int niters &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  int niters &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 0) {
    if (args[0]-&gt;IsNumber()) mode &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 0) {
    if (info[0]-&gt;IsNumber()) mode &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   if (args.Length() &gt; 1) {
    if (args[1]-&gt;IsNumber()) chain &#x3D; args[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   if (info.Length() &gt; 1) {
    if (info[1]-&gt;IsNumber()) chain &#x3D; info[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Local&lt;Object&gt; conts_to_return&#x3D; NanNew(Contour::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Contour *contours &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(conts_to_return);
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Local&lt;Object&gt; conts_to_return&#x3D; Nan::New(Contour::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Contour *contours &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(conts_to_return);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(conts_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(conts_to_return);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Contour *cont &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args[0]-&gt;ToObject());
  int pos &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Contour *cont &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info[0]-&gt;ToObject());
  int pos &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   if (args[2]-&gt;IsArray()) {
    Local&lt;Object&gt; objColor &#x3D; args[2]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[2]-&gt;IsArray()) {
    Local&lt;Object&gt; objColor &#x3D; info[2]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   int thickness &#x3D; args.Length() &lt; 4 ? 1 : args[3]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   int thickness &#x3D; info.Length() &lt; 4 ? 1 : info[3]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Contour *cont &#x3D; ObjectWrap::Unwrap&lt;Contour&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Contour *cont &#x3D; Nan::ObjectWrap::Unwrap&lt;Contour&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   if (args[1]-&gt;IsArray()) {
    Local&lt;Object&gt; objColor &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[1]-&gt;IsArray()) {
    Local&lt;Object&gt; objColor &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   int thickness &#x3D; args.Length() &lt; 3 ? 1 : args[2]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   int thickness &#x3D; info.Length() &lt; 3 ? 1 : info[2]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Array&gt; arr &#x3D; NanNew&lt;Array&gt;(corners.size());
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Array&gt; arr &#x3D; Nan::New&lt;Array&gt;(corners.size());
</code></pre>
                <pre><code class="removed">-     v8::Local&lt;v8::Array&gt; pt &#x3D; NanNew&lt;Array&gt;(2);
    pt-&gt;Set(0, NanNew&lt;Number&gt;((double) corners[i].x));
    pt-&gt;Set(1, NanNew&lt;Number&gt;((double) corners[i].y));
</code></pre>
                <pre><code class="added">+     v8::Local&lt;v8::Array&gt; pt &#x3D; Nan::New&lt;Array&gt;(2);
    pt-&gt;Set(0, Nan::New&lt;Number&gt;((double) corners[i].x));
    pt-&gt;Set(1, Nan::New&lt;Number&gt;((double) corners[i].y));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  double rho &#x3D; args.Length() &lt; 1 ? 1 : args[0]-&gt;NumberValue();
  double theta &#x3D; args.Length() &lt; 2 ? CV_PI/180 : args[1]-&gt;NumberValue();
  int threshold &#x3D; args.Length() &lt; 3 ? 80 : args[2]-&gt;Uint32Value();
  double minLineLength &#x3D; args.Length() &lt; 4 ? 30 : args[3]-&gt;NumberValue();
  double maxLineGap &#x3D; args.Length() &lt; 5 ? 10 : args[4]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  double rho &#x3D; info.Length() &lt; 1 ? 1 : info[0]-&gt;NumberValue();
  double theta &#x3D; info.Length() &lt; 2 ? CV_PI/180 : info[1]-&gt;NumberValue();
  int threshold &#x3D; info.Length() &lt; 3 ? 80 : info[2]-&gt;Uint32Value();
  double minLineLength &#x3D; info.Length() &lt; 4 ? 30 : info[3]-&gt;NumberValue();
  double maxLineGap &#x3D; info.Length() &lt; 5 ? 10 : info[4]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Array&gt; arr &#x3D; NanNew&lt;Array&gt;(lines.size());
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Array&gt; arr &#x3D; Nan::New&lt;Array&gt;(lines.size());
</code></pre>
                <pre><code class="removed">-     v8::Local&lt;v8::Array&gt; pt &#x3D; NanNew&lt;Array&gt;(4);
    pt-&gt;Set(0, NanNew&lt;Number&gt;((double) lines[i][0]));
    pt-&gt;Set(1, NanNew&lt;Number&gt;((double) lines[i][1]));
    pt-&gt;Set(2, NanNew&lt;Number&gt;((double) lines[i][2]));
    pt-&gt;Set(3, NanNew&lt;Number&gt;((double) lines[i][3]));
</code></pre>
                <pre><code class="added">+     v8::Local&lt;v8::Array&gt; pt &#x3D; Nan::New&lt;Array&gt;(4);
    pt-&gt;Set(0, Nan::New&lt;Number&gt;((double) lines[i][0]));
    pt-&gt;Set(1, Nan::New&lt;Number&gt;((double) lines[i][1]));
    pt-&gt;Set(2, Nan::New&lt;Number&gt;((double) lines[i][2]));
    pt-&gt;Set(3, Nan::New&lt;Number&gt;((double) lines[i][3]));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   double dp &#x3D; args.Length() &lt; 1 ? 1 : args[0]-&gt;NumberValue();
  double minDist &#x3D; args.Length() &lt; 2 ? 1 : args[1]-&gt;NumberValue();
  double higherThreshold &#x3D; args.Length() &lt; 3 ? 100 : args[2]-&gt;NumberValue();
  double accumulatorThreshold &#x3D; args.Length() &lt; 4 ? 100 : args[3]-&gt;NumberValue();
  int minRadius &#x3D; args.Length() &lt; 5 ? 0 : args[4]-&gt;Uint32Value();
  int maxRadius &#x3D; args.Length() &lt; 6 ? 0 : args[5]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   double dp &#x3D; info.Length() &lt; 1 ? 1 : info[0]-&gt;NumberValue();
  double minDist &#x3D; info.Length() &lt; 2 ? 1 : info[1]-&gt;NumberValue();
  double higherThreshold &#x3D; info.Length() &lt; 3 ? 100 : info[2]-&gt;NumberValue();
  double accumulatorThreshold &#x3D; info.Length() &lt; 4 ? 100 : info[3]-&gt;NumberValue();
  int minRadius &#x3D; info.Length() &lt; 5 ? 0 : info[4]-&gt;Uint32Value();
  int maxRadius &#x3D; info.Length() &lt; 6 ? 0 : info[5]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Array&gt; arr &#x3D; NanNew&lt;Array&gt;(circles.size());
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Array&gt; arr &#x3D; Nan::New&lt;Array&gt;(circles.size());
</code></pre>
                <pre><code class="removed">-     v8::Local&lt;v8::Array&gt; pt &#x3D; NanNew&lt;Array&gt;(3);
    pt-&gt;Set(0, NanNew&lt;Number&gt;((double) circles[i][0]));  // center x
    pt-&gt;Set(1, NanNew&lt;Number&gt;((double) circles[i][1]));// center y
    pt-&gt;Set(2, NanNew&lt;Number&gt;((double) circles[i][2]));// radius
</code></pre>
                <pre><code class="added">+     v8::Local&lt;v8::Array&gt; pt &#x3D; Nan::New&lt;Array&gt;(3);
    pt-&gt;Set(0, Nan::New&lt;Number&gt;((double) circles[i][0]));  // center x
    pt-&gt;Set(1, Nan::New&lt;Number&gt;((double) circles[i][1]));// center y
    pt-&gt;Set(2, Nan::New&lt;Number&gt;((double) circles[i][2]));// radius
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[0]-&gt;Uint32Value();
  int y &#x3D; args[1]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[0]-&gt;Uint32Value();
  int y &#x3D; info[1]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   int interpolation &#x3D; (args.Length() &lt; 3) ? (int)cv::INTER_LINEAR : args[2]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   int interpolation &#x3D; (info.Length() &lt; 3) ? (int)cv::INTER_LINEAR : info[2]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   float angle &#x3D; args[0]-&gt;ToNumber()-&gt;Value();
</code></pre>
                <pre><code class="added">+   float angle &#x3D; info[0]-&gt;ToNumber()-&gt;Value();
</code></pre>
                <pre><code class="removed">-       &amp;&amp; (args.Length() &#x3D;&#x3D; 1);
</code></pre>
                <pre><code class="added">+       &amp;&amp; (info.Length() &#x3D;&#x3D; 1);
</code></pre>
                <pre><code class="removed">-     if (!angle2) {NanReturnUndefined();}
</code></pre>
                <pre><code class="added">+     if (!angle2) {return;}
</code></pre>
                <pre><code class="removed">-     NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     return;
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[1]-&gt;IsUndefined() ? round(self-&gt;mat.size().width / 2) :
      args[1]-&gt;Uint32Value();
  int y &#x3D; args[1]-&gt;IsUndefined() ? round(self-&gt;mat.size().height / 2) :
      args[2]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[1]-&gt;IsUndefined() ? round(self-&gt;mat.size().width / 2) :
      info[1]-&gt;Uint32Value();
  int y &#x3D; info[1]-&gt;IsUndefined() ? round(self-&gt;mat.size().height / 2) :
      info[2]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-    NanThrowError(String::New(&quot;Image is no 3-channel&quot;));*/
</code></pre>
                <pre><code class="added">+    Nan::ThrowError(String::New(&quot;Image is no 3-channel&quot;));*/
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsArray() &amp;&amp; args[1]-&gt;IsArray()) {
    Local&lt;Object&gt; args_lowerb &#x3D; args[0]-&gt;ToObject();
    Local&lt;Object&gt; args_upperb &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsArray() &amp;&amp; info[1]-&gt;IsArray()) {
    Local&lt;Object&gt; args_lowerb &#x3D; info[0]-&gt;ToObject();
    Local&lt;Object&gt; args_upperb &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   int dtop &#x3D; args[0]-&gt;Uint32Value();
  int dbottom &#x3D; args[1]-&gt;Uint32Value();
  int dleft &#x3D; args[2]-&gt;Uint32Value();
  int dright &#x3D; args[3]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   int dtop &#x3D; info[0]-&gt;Uint32Value();
  int dbottom &#x3D; info[1]-&gt;Uint32Value();
  int dleft &#x3D; info[2]-&gt;Uint32Value();
  int dright &#x3D; info[3]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(4);
  arr-&gt;Set(0, NanNew&lt;Number&gt;(wholeSize.width));
  arr-&gt;Set(1, NanNew&lt;Number&gt;(wholeSize.height));
  arr-&gt;Set(2, NanNew&lt;Number&gt;(ofs.x));
  arr-&gt;Set(3, NanNew&lt;Number&gt;(ofs.y));
</code></pre>
                <pre><code class="added">+   v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(4);
  arr-&gt;Set(0, Nan::New&lt;Number&gt;(wholeSize.width));
  arr-&gt;Set(1, Nan::New&lt;Number&gt;(wholeSize.height));
  arr-&gt;Set(2, Nan::New&lt;Number&gt;(ofs.x));
  arr-&gt;Set(3, Nan::New&lt;Number&gt;(ofs.y));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   double threshold &#x3D; args[0]-&gt;NumberValue();
  double maxVal &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   double threshold &#x3D; info[0]-&gt;NumberValue();
  double maxVal &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 3) {
    //    typ &#x3D; args[2]-&gt;IntegerValue();
    NanAsciiString typstr(args[2]);
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 3) {
    //    typ &#x3D; info[2]-&gt;IntegerValue();
    Nan::Utf8String typstr(info[2]);
</code></pre>
                <pre><code class="removed">-       NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="added">+       Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(img_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(img_to_return);
</code></pre>
                <pre><code class="removed">-   double maxVal &#x3D; args[0]-&gt;NumberValue();
  double adaptiveMethod &#x3D; args[1]-&gt;NumberValue();
  double thresholdType &#x3D; args[2]-&gt;NumberValue();
  double blockSize &#x3D; args[3]-&gt;NumberValue();
  double C &#x3D; args[4]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   double maxVal &#x3D; info[0]-&gt;NumberValue();
  double adaptiveMethod &#x3D; info[1]-&gt;NumberValue();
  double thresholdType &#x3D; info[2]-&gt;NumberValue();
  double blockSize &#x3D; info[3]-&gt;NumberValue();
  double C &#x3D; info[4]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-       NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="added">+       Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(img_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(img_to_return);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; mean &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *m_mean &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(mean);
  Local&lt;Object&gt; stddev &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *m_stddev &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(stddev);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; mean &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *m_mean &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(mean);
  Local&lt;Object&gt; stddev &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *m_stddev &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(stddev);
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; data &#x3D; NanNew&lt;Object&gt;();
  data-&gt;Set(NanNew&lt;String&gt;(&quot;mean&quot;), mean);
  data-&gt;Set(NanNew&lt;String&gt;(&quot;stddev&quot;), stddev);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; data &#x3D; Nan::New&lt;Object&gt;();
  data-&gt;Set(Nan::New&lt;String&gt;(&quot;mean&quot;).ToLocalChecked(), mean);
  data-&gt;Set(Nan::New&lt;String&gt;(&quot;stddev&quot;).ToLocalChecked(), stddev);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(data);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(data);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix * self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix * self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Matrix *dest &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *dest &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[1]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   int y &#x3D; args[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int y &#x3D; info[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix * self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix * self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   v8::String::Utf8Value str (args[0]-&gt;ToString());
</code></pre>
                <pre><code class="added">+   v8::String::Utf8Value str (info[0]-&gt;ToString());
</code></pre>
                <pre><code class="removed">-     NanThrowTypeError(&quot;Conversion code is unsupported&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowTypeError(&quot;Conversion code is unsupported&quot;);
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix * self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix * self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   v8::Local&lt;v8::Array&gt; arrChannels &#x3D; NanNew&lt;Array&gt;(size);
</code></pre>
                <pre><code class="added">+   v8::Local&lt;v8::Array&gt; arrChannels &#x3D; Nan::New&lt;Array&gt;(size);
</code></pre>
                <pre><code class="removed">-         NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix * m &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(matObject);
</code></pre>
                <pre><code class="added">+         Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix * m &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(matObject);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arrChannels);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arrChannels);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix * self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  if (!args[0]-&gt;IsArray()) {
    NanThrowTypeError(&quot;The argument must be an array&quot;);
</code></pre>
                <pre><code class="added">+   Matrix * self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  if (!info[0]-&gt;IsArray()) {
    Nan::ThrowTypeError(&quot;The argument must be an array&quot;);
</code></pre>
                <pre><code class="removed">-   v8::Handle&lt;v8::Array&gt; jsChannels &#x3D; v8::Handle&lt;v8::Array&gt;::Cast(args[0]);
</code></pre>
                <pre><code class="added">+   v8::Handle&lt;v8::Array&gt; jsChannels &#x3D; v8::Handle&lt;v8::Array&gt;::Cast(info[0]);
</code></pre>
                <pre><code class="removed">-     Matrix * matObject &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(jsChannels-&gt;Get(i)-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix * matObject &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(jsChannels-&gt;Get(i)-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
  Matrix * self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  Matrix * self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   // obj-&gt;Get(NanNew&lt;String&gt;(&quot;x&quot;))
</code></pre>
                <pre><code class="added">+   // obj-&gt;Get(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked())
</code></pre>
                <pre><code class="removed">-   if (args.Length() &lt; 1 || !args[0]-&gt;IsObject()) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &lt; 1 || !info[0]-&gt;IsObject()) {
</code></pre>
                <pre><code class="removed">-   Local &lt; Object &gt; obj &#x3D; args[0]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   Local &lt; Object &gt; obj &#x3D; info[0]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-       setPoint(obj-&gt;Get(NanNew&lt;String&gt;(&quot;seedPoint&quot;))-&gt;ToObject()),
      setColor(obj-&gt;Get(NanNew&lt;String&gt;(&quot;newColor&quot;))-&gt;ToObject()),
      obj-&gt;Get(NanNew&lt;String&gt;(&quot;rect&quot;))-&gt;IsUndefined() ?
          0 : setRect(obj-&gt;Get(NanNew&lt;String&gt;(&quot;rect&quot;))-&gt;ToObject(), rect),
      setColor(obj-&gt;Get(NanNew&lt;String&gt;(&quot;loDiff&quot;))-&gt;ToObject()),
      setColor(obj-&gt;Get(NanNew&lt;String&gt;(&quot;upDiff&quot;))-&gt;ToObject()), 4);
</code></pre>
                <pre><code class="added">+       setPoint(obj-&gt;Get(Nan::New&lt;String&gt;(&quot;seedPoint&quot;).ToLocalChecked())-&gt;ToObject()),
      setColor(obj-&gt;Get(Nan::New&lt;String&gt;(&quot;newColor&quot;).ToLocalChecked())-&gt;ToObject()),
      obj-&gt;Get(Nan::New&lt;String&gt;(&quot;rect&quot;).ToLocalChecked())-&gt;IsUndefined() ?
          0 : setRect(obj-&gt;Get(Nan::New&lt;String&gt;(&quot;rect&quot;).ToLocalChecked())-&gt;ToObject(), rect),
      setColor(obj-&gt;Get(Nan::New&lt;String&gt;(&quot;loDiff&quot;).ToLocalChecked())-&gt;ToObject()),
      setColor(obj-&gt;Get(Nan::New&lt;String&gt;(&quot;upDiff&quot;).ToLocalChecked())-&gt;ToObject()), 4);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(ret));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(ret));
</code></pre>
                <pre><code class="removed">-       (args.Length() &gt;&#x3D; 1) ? args[0]-&gt;IsNumber() : false;
</code></pre>
                <pre><code class="added">+       (info.Length() &gt;&#x3D; 1) ? info[0]-&gt;IsNumber() : false;
</code></pre>
                <pre><code class="removed">-       (args.Length() &gt;&#x3D; 2) ? args[1]-&gt;IsNumber() : false;
  double min_probability &#x3D; filter_min_probability ? args[0]-&gt;NumberValue() : 0;
  double max_probability &#x3D; filter_max_probability ? args[1]-&gt;NumberValue() : 0;
  int limit &#x3D; (args.Length() &gt;&#x3D; 3) ? args[2]-&gt;IntegerValue() : 0;
  bool ascending &#x3D; (args.Length() &gt;&#x3D; 4) ? args[3]-&gt;BooleanValue() : false;
  int min_x_distance &#x3D; (args.Length() &gt;&#x3D; 5) ? args[4]-&gt;IntegerValue() : 0;
  int min_y_distance &#x3D; (args.Length() &gt;&#x3D; 6) ? args[5]-&gt;IntegerValue() : 0;
</code></pre>
                <pre><code class="added">+       (info.Length() &gt;&#x3D; 2) ? info[1]-&gt;IsNumber() : false;
  double min_probability &#x3D; filter_min_probability ? info[0]-&gt;NumberValue() : 0;
  double max_probability &#x3D; filter_max_probability ? info[1]-&gt;NumberValue() : 0;
  int limit &#x3D; (info.Length() &gt;&#x3D; 3) ? info[2]-&gt;IntegerValue() : 0;
  bool ascending &#x3D; (info.Length() &gt;&#x3D; 4) ? info[3]-&gt;BooleanValue() : false;
  int min_x_distance &#x3D; (info.Length() &gt;&#x3D; 5) ? info[4]-&gt;IntegerValue() : 0;
  int min_y_distance &#x3D; (info.Length() &gt;&#x3D; 6) ? info[5]-&gt;IntegerValue() : 0;
</code></pre>
                <pre><code class="removed">-   v8::Local &lt; v8::Array &gt; probabilites_array &#x3D; NanNew&lt;v8::Array&gt;(limit);
</code></pre>
                <pre><code class="added">+   v8::Local &lt; v8::Array &gt; probabilites_array &#x3D; Nan::New&lt;v8::Array&gt;(limit);
</code></pre>
                <pre><code class="removed">-     Local&lt;Value&gt; x_value &#x3D; NanNew&lt;Number&gt;(pt.x);
    Local&lt;Value&gt; y_value &#x3D; NanNew&lt;Number&gt;(pt.y);
    Local&lt;Value&gt; probability_value &#x3D; NanNew&lt;Number&gt;(probability);
</code></pre>
                <pre><code class="added">+     Local&lt;Value&gt; x_value &#x3D; Nan::New&lt;Number&gt;(pt.x);
    Local&lt;Value&gt; y_value &#x3D; Nan::New&lt;Number&gt;(pt.y);
    Local&lt;Value&gt; probability_value &#x3D; Nan::New&lt;Number&gt;(probability);
</code></pre>
                <pre><code class="removed">-     Local &lt; Object &gt; probability_object &#x3D; NanNew&lt;Object&gt;();
    probability_object-&gt;Set(NanNew&lt;String&gt;(&quot;x&quot;), x_value);
    probability_object-&gt;Set(NanNew&lt;String&gt;(&quot;y&quot;), y_value);
    probability_object-&gt;Set(NanNew&lt;String&gt;(&quot;probability&quot;), probability_value);
</code></pre>
                <pre><code class="added">+     Local &lt; Object &gt; probability_object &#x3D; Nan::New&lt;Object&gt;();
    probability_object-&gt;Set(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked(), x_value);
    probability_object-&gt;Set(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked(), y_value);
    probability_object-&gt;Set(Nan::New&lt;String&gt;(&quot;probability&quot;).ToLocalChecked(), probability_value);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(probabilites_array);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(probabilites_array);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   v8::String::Utf8Value args0(args[0]-&gt;ToString());
</code></pre>
                <pre><code class="added">+   v8::String::Utf8Value args0(info[0]-&gt;ToString());
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; out &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *m_out &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(out);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; out &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *m_out &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(out);
</code></pre>
                <pre><code class="removed">-   int method &#x3D; (args.Length() &lt; 2) ? (int)cv::TM_CCORR_NORMED : args[1]-&gt;Uint32Value();
</code></pre>
                <pre><code class="added">+   int method &#x3D; (info.Length() &lt; 2) ? (int)cv::TM_CCORR_NORMED : info[1]-&gt;Uint32Value();
</code></pre>
                <pre><code class="removed">-   NanReturnValue(out);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(out);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Local&lt;Value&gt; v_minVal &#x3D; NanNew&lt;Number&gt;(minVal);
  Local&lt;Value&gt; v_maxVal &#x3D; NanNew&lt;Number&gt;(maxVal);
  Local&lt;Value&gt; v_minLoc_x &#x3D; NanNew&lt;Number&gt;(minLoc.x);
  Local&lt;Value&gt; v_minLoc_y &#x3D; NanNew&lt;Number&gt;(minLoc.y);
  Local&lt;Value&gt; v_maxLoc_x &#x3D; NanNew&lt;Number&gt;(maxLoc.x);
  Local&lt;Value&gt; v_maxLoc_y &#x3D; NanNew&lt;Number&gt;(maxLoc.y);
</code></pre>
                <pre><code class="added">+   Local&lt;Value&gt; v_minVal &#x3D; Nan::New&lt;Number&gt;(minVal);
  Local&lt;Value&gt; v_maxVal &#x3D; Nan::New&lt;Number&gt;(maxVal);
  Local&lt;Value&gt; v_minLoc_x &#x3D; Nan::New&lt;Number&gt;(minLoc.x);
  Local&lt;Value&gt; v_minLoc_y &#x3D; Nan::New&lt;Number&gt;(minLoc.y);
  Local&lt;Value&gt; v_maxLoc_x &#x3D; Nan::New&lt;Number&gt;(maxLoc.x);
  Local&lt;Value&gt; v_maxLoc_y &#x3D; Nan::New&lt;Number&gt;(maxLoc.y);
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; o_minLoc &#x3D; NanNew&lt;Object&gt;();
  o_minLoc-&gt;Set(NanNew&lt;String&gt;(&quot;x&quot;), v_minLoc_x);
  o_minLoc-&gt;Set(NanNew&lt;String&gt;(&quot;y&quot;), v_minLoc_y);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; o_minLoc &#x3D; Nan::New&lt;Object&gt;();
  o_minLoc-&gt;Set(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked(), v_minLoc_x);
  o_minLoc-&gt;Set(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked(), v_minLoc_y);
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; o_maxLoc &#x3D; NanNew&lt;Object&gt;();
  o_maxLoc-&gt;Set(NanNew&lt;String&gt;(&quot;x&quot;), v_maxLoc_x);
  o_maxLoc-&gt;Set(NanNew&lt;String&gt;(&quot;y&quot;), v_maxLoc_y);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; o_maxLoc &#x3D; Nan::New&lt;Object&gt;();
  o_maxLoc-&gt;Set(Nan::New&lt;String&gt;(&quot;x&quot;).ToLocalChecked(), v_maxLoc_x);
  o_maxLoc-&gt;Set(Nan::New&lt;String&gt;(&quot;y&quot;).ToLocalChecked(), v_maxLoc_y);
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; result &#x3D; NanNew&lt;Object&gt;();
  result-&gt;Set(NanNew&lt;String&gt;(&quot;minVal&quot;), v_minVal);
  result-&gt;Set(NanNew&lt;String&gt;(&quot;maxVal&quot;), v_maxVal);
  result-&gt;Set(NanNew&lt;String&gt;(&quot;minLoc&quot;), o_minLoc);
  result-&gt;Set(NanNew&lt;String&gt;(&quot;maxLoc&quot;), o_maxLoc);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; result &#x3D; Nan::New&lt;Object&gt;();
  result-&gt;Set(Nan::New&lt;String&gt;(&quot;minVal&quot;).ToLocalChecked(), v_minVal);
  result-&gt;Set(Nan::New&lt;String&gt;(&quot;maxVal&quot;).ToLocalChecked(), v_maxVal);
  result-&gt;Set(Nan::New&lt;String&gt;(&quot;minLoc&quot;).ToLocalChecked(), o_minLoc);
  result-&gt;Set(Nan::New&lt;String&gt;(&quot;maxLoc&quot;).ToLocalChecked(), o_maxLoc);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(result);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(result);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  Matrix *m_input &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Matrix *m_input &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(args.This());
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(info.This());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
  NanAsciiString textString(args[0]);  //FIXME: might cause issues, see here https://github.com/rvagg/nan/pull/152
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
  Nan::Utf8String textString(info[0]);  //FIXME: might cause issues, see here https://github.com/rvagg/nan/pull/152
</code></pre>
                <pre><code class="removed">-   int x &#x3D; args[1]-&gt;IntegerValue();
  int y &#x3D; args[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int x &#x3D; info[1]-&gt;IntegerValue();
  int y &#x3D; info[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanAsciiString fontString(args[3]);
</code></pre>
                <pre><code class="added">+   Nan::Utf8String fontString(info[3]);
</code></pre>
                <pre><code class="removed">-   if (args[4]-&gt;IsArray()) {
    Local&lt;Object&gt; objColor &#x3D; args[4]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[4]-&gt;IsArray()) {
    Local&lt;Object&gt; objColor &#x3D; info[4]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   double scale &#x3D; args.Length() &lt; 6 ? 1 : args[5]-&gt;NumberValue();
  double thickness &#x3D; args.Length() &lt; 7 ? 1 : args[6]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   double scale &#x3D; info.Length() &lt; 6 ? 1 : info[5]-&gt;NumberValue();
  double thickness &#x3D; info.Length() &lt; 7 ? 1 : info[6]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   // extract quad args
  Local&lt;Object&gt; srcArray &#x3D; args[0]-&gt;ToObject();
  Local&lt;Object&gt; tgtArray &#x3D; args[1]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   // extract quad info
  Local&lt;Object&gt; srcArray &#x3D; info[0]-&gt;ToObject();
  Local&lt;Object&gt; tgtArray &#x3D; info[1]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; xfrm &#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *xfrmmat &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(xfrm);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; xfrm &#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *xfrmmat &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(xfrm);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(xfrm);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(xfrm);
</code></pre>
                <pre><code class="removed">-   Matrix *xfrm &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *xfrm &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   int width &#x3D; args[1]-&gt;IntegerValue();
  int height &#x3D; args[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int width &#x3D; info[1]-&gt;IntegerValue();
  int height &#x3D; info[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   if (args[3]-&gt;IsArray()) {
    Local &lt; Object &gt; objColor &#x3D; args[3]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   if (info[3]-&gt;IsArray()) {
    Local &lt; Object &gt; objColor &#x3D; info[3]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   NanReturnNull();
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::Null());
</code></pre>
                <pre><code class="removed">-   Matrix *dest &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *dest &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   Matrix *mask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *mask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   Local &lt; Object &gt; valArray &#x3D; args[0]-&gt;ToObject();
</code></pre>
                <pre><code class="added">+   Local &lt; Object &gt; valArray &#x3D; info[0]-&gt;ToObject();
</code></pre>
                <pre><code class="removed">-   Matrix *mask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *mask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   Matrix *mask &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Matrix *mask &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   v8::Local &lt; v8::Array &gt; arr &#x3D; NanNew&lt;Array&gt;(3);
  arr-&gt;Set(0, NanNew&lt;Number&gt;(means[0]));
  arr-&gt;Set(1, NanNew&lt;Number&gt;(means[1]));
  arr-&gt;Set(2, NanNew&lt;Number&gt;(means[2]));
</code></pre>
                <pre><code class="added">+   v8::Local &lt; v8::Array &gt; arr &#x3D; Nan::New&lt;Array&gt;(3);
  arr-&gt;Set(0, Nan::New&lt;Number&gt;(means[0]));
  arr-&gt;Set(1, Nan::New&lt;Number&gt;(means[1]));
  arr-&gt;Set(2, Nan::New&lt;Number&gt;(means[2]));
</code></pre>
                <pre><code class="removed">-   NanReturnValue(arr);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(arr);
</code></pre>
                <pre><code class="removed">-   double tx &#x3D; args[0]-&gt;NumberValue();
  double ty &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   double tx &#x3D; info[0]-&gt;NumberValue();
  double ty &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   // get the integer values of args
</code></pre>
                <pre><code class="added">+   // get the integer values of info
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Matrix *self &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Matrix *self &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Point.cc</h3>
          <div class="diff">
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; Point::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; Point::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(Point::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(Point::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;Point&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;Point&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   proto-&gt;SetAccessor(NanNew(&quot;x&quot;), GetX, RaiseImmutable);
  proto-&gt;SetAccessor(NanNew(&quot;y&quot;), GetY, RaiseImmutable);
</code></pre>
                <pre><code class="added">+   Nan::SetAccessor(proto, Nan::New(&quot;x&quot;).ToLocalChecked(), GetX, RaiseImmutable);
  Nan::SetAccessor(proto, Nan::New(&quot;y&quot;).ToLocalChecked(), GetY, RaiseImmutable);
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;dot&quot;, Dot);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;dot&quot;, Dot);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;Point&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;Point&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    return NanThrowTypeError(&quot;Cannot Instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    return Nan::ThrowTypeError(&quot;Cannot Instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsNumber()) {
    x &#x3D; args[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsNumber()) {
    x &#x3D; info[0]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   if (args[1]-&gt;IsNumber()) {
    y &#x3D; args[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="added">+   if (info[1]-&gt;IsNumber()) {
    y &#x3D; info[1]-&gt;NumberValue();
</code></pre>
                <pre><code class="removed">-   pt-&gt;Wrap(args.This());
  NanReturnValue(args.This());
</code></pre>
                <pre><code class="added">+   pt-&gt;Wrap(info.This());
  info.GetReturnValue().Set(info.This());
</code></pre>
                <pre><code class="removed">-   NanScope();
  Point *pt &#x3D; ObjectWrap::Unwrap&lt;Point&gt;(args.This());
  NanReturnValue(NanNew&lt;Number&gt;(pt-&gt;point.x));
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  Point *pt &#x3D; Nan::ObjectWrap::Unwrap&lt;Point&gt;(info.This());
  info.GetReturnValue().Set(Nan::New&lt;Number&gt;(pt-&gt;point.x));
</code></pre>
                <pre><code class="removed">-   NanScope();
  Point *pt &#x3D; ObjectWrap::Unwrap&lt;Point&gt;(args.This());
  NanReturnValue(NanNew&lt;Number&gt;(pt-&gt;point.y));
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  Point *pt &#x3D; Nan::ObjectWrap::Unwrap&lt;Point&gt;(info.This());
  info.GetReturnValue().Set(Nan::New&lt;Number&gt;(pt-&gt;point.y));
</code></pre>
                <pre><code class="removed">-   NanThrowTypeError(&quot;Point is immutable&quot;);
</code></pre>
                <pre><code class="added">+   Nan::ThrowTypeError(&quot;Point is immutable&quot;);
</code></pre>
                <pre><code class="removed">-   NanScope();
  Point *p1 &#x3D; ObjectWrap::Unwrap&lt;Point&gt;(args.This());
  Point *p2 &#x3D; ObjectWrap::Unwrap&lt;Point&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  Point *p1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Point&gt;(info.This());
  Point *p2 &#x3D; Nan::ObjectWrap::Unwrap&lt;Point&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(NanNew&lt;Number&gt;(p1-&gt;point.x * p2-&gt;point.x + p1-&gt;point.y * p2-&gt;point.y));
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(Nan::New&lt;Number&gt;(p1-&gt;point.x * p2-&gt;point.x + p1-&gt;point.y * p2-&gt;point.y));
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Point.h</h3>
          <div class="diff">
                <pre><code class="removed">- class Point: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class Point: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Stereo.cc</h3>
          <div class="diff">
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; StereoBM::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; StereoBM::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(StereoBM::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(StereoBM::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;StereoBM&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;StereoBM&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;compute&quot;, Compute);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;compute&quot;, Compute);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;Set(NanNew&lt;String&gt;(&quot;BASIC_PRESET&quot;), NanNew&lt;Integer&gt;((int)cv::StereoBM::BASIC_PRESET));
  ctor-&gt;Set(NanNew&lt;String&gt;(&quot;FISH_EYE_PRESET&quot;), NanNew&lt;Integer&gt;((int)cv::StereoBM::FISH_EYE_PRESET));
  ctor-&gt;Set(NanNew&lt;String&gt;(&quot;NARROW_PRESET&quot;), NanNew&lt;Integer&gt;((int)cv::StereoBM::NARROW_PRESET));
</code></pre>
                <pre><code class="added">+   ctor-&gt;Set(Nan::New&lt;String&gt;(&quot;BASIC_PRESET&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;((int)cv::StereoBM::BASIC_PRESET));
  ctor-&gt;Set(Nan::New&lt;String&gt;(&quot;FISH_EYE_PRESET&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;((int)cv::StereoBM::FISH_EYE_PRESET));
  ctor-&gt;Set(Nan::New&lt;String&gt;(&quot;NARROW_PRESET&quot;).ToLocalChecked(), Nan::New&lt;Integer&gt;((int)cv::StereoBM::NARROW_PRESET));
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;StereoBM&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;StereoBM&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    NanThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    Nan::ThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   } else if (args.Length() &#x3D;&#x3D; 1) {
</code></pre>
                <pre><code class="added">+   } else if (info.Length() &#x3D;&#x3D; 1) {
</code></pre>
                <pre><code class="removed">-     stereo &#x3D; new StereoBM(args[0]-&gt;IntegerValue());
  } else if (args.Length() &#x3D;&#x3D; 2) {
</code></pre>
                <pre><code class="added">+     stereo &#x3D; new StereoBM(info[0]-&gt;IntegerValue());
  } else if (info.Length() &#x3D;&#x3D; 2) {
</code></pre>
                <pre><code class="removed">-     stereo &#x3D; new StereoBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+     stereo &#x3D; new StereoBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-     stereo &#x3D; new StereoBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
</code></pre>
                <pre><code class="added">+     stereo &#x3D; new StereoBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
</code></pre>
                <pre><code class="removed">-         args[2]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         info[2]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-   stereo-&gt;Wrap(args.Holder());
  NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   stereo-&gt;Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-     ObjectWrap(),
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap(),
</code></pre>
                <pre><code class="removed">-     Matrix* m0 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m0 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     if (args.Length() &gt; 2) {
      type &#x3D; args[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+     if (info.Length() &gt; 2) {
      type &#x3D; info[2]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-         NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *disp &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(disparityWrap);
</code></pre>
                <pre><code class="added">+         Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *disp &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(disparityWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(disparityWrap);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(disparityWrap);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; StereoSGBM::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; StereoSGBM::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(StereoSGBM::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(StereoSGBM::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;StereoSGBM&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;StereoSGBM&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;compute&quot;, Compute);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;compute&quot;, Compute);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;StereoSGBM&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;StereoSGBM&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    NanThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0) {
    Nan::ThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-     if (args.Length() &gt;&#x3D; 3) {
      switch (args.Length()) {
</code></pre>
                <pre><code class="added">+     if (info.Length() &gt;&#x3D; 3) {
      switch (info.Length()) {
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue(),
            args[5]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue(),
            info[5]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue(),
            args[5]-&gt;IntegerValue(), args[6]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue(),
            info[5]-&gt;IntegerValue(), info[6]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue(),
            args[5]-&gt;IntegerValue(), args[6]-&gt;IntegerValue(), args[7]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue(),
            info[5]-&gt;IntegerValue(), info[6]-&gt;IntegerValue(), info[7]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue(),
            args[5]-&gt;IntegerValue(), args[6]-&gt;IntegerValue(), args[7]-&gt;IntegerValue(),
            args[8]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue(),
            info[5]-&gt;IntegerValue(), info[6]-&gt;IntegerValue(), info[7]-&gt;IntegerValue(),
            info[8]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue(),
            args[5]-&gt;IntegerValue(), args[6]-&gt;IntegerValue(), args[7]-&gt;IntegerValue(),
            args[8]-&gt;IntegerValue(), args[9]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue(),
            info[5]-&gt;IntegerValue(), info[6]-&gt;IntegerValue(), info[7]-&gt;IntegerValue(),
            info[8]-&gt;IntegerValue(), info[9]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-         stereo &#x3D; new StereoSGBM(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue(),
            args[2]-&gt;IntegerValue(), args[3]-&gt;IntegerValue(), args[4]-&gt;IntegerValue(),
            args[5]-&gt;IntegerValue(), args[6]-&gt;IntegerValue(), args[7]-&gt;IntegerValue(),
            args[8]-&gt;IntegerValue(), args[9]-&gt;IntegerValue(), args[10]-&gt;ToBoolean()-&gt;Value());
</code></pre>
                <pre><code class="added">+         stereo &#x3D; new StereoSGBM(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue(),
            info[2]-&gt;IntegerValue(), info[3]-&gt;IntegerValue(), info[4]-&gt;IntegerValue(),
            info[5]-&gt;IntegerValue(), info[6]-&gt;IntegerValue(), info[7]-&gt;IntegerValue(),
            info[8]-&gt;IntegerValue(), info[9]-&gt;IntegerValue(), info[10]-&gt;ToBoolean()-&gt;Value());
</code></pre>
                <pre><code class="removed">-       NanThrowError(&quot;If overriding default settings, must pass minDisparity, numDisparities, and SADWindowSize&quot;);
      NanReturnUndefined();
</code></pre>
                <pre><code class="added">+       Nan::ThrowError(&quot;If overriding default settings, must pass minDisparity, numDisparities, and SADWindowSize&quot;);
      return;
</code></pre>
                <pre><code class="removed">-   stereo-&gt;Wrap(args.Holder());
  NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   stereo-&gt;Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-     ObjectWrap(),
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap(),
</code></pre>
                <pre><code class="removed">-     ObjectWrap(),
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap(),
</code></pre>
                <pre><code class="removed">-     Matrix* m0 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m0 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-         NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *disp &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(disparityWrap);
</code></pre>
                <pre><code class="added">+         Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *disp &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(disparityWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(disparityWrap);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(disparityWrap);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; StereoGC::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; StereoGC::constructor;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(StereoGC::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(StereoGC::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;StereoGC&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;StereoGC&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;compute&quot;, Compute);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;compute&quot;, Compute);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;StereoGC&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;StereoGC&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0)
  NanThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0)
  Nan::ThrowTypeError(&quot;Cannot instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   if (args.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="added">+   if (info.Length() &#x3D;&#x3D; 0) {
</code></pre>
                <pre><code class="removed">-   } else if (args.Length() &#x3D;&#x3D; 1) {
</code></pre>
                <pre><code class="added">+   } else if (info.Length() &#x3D;&#x3D; 1) {
</code></pre>
                <pre><code class="removed">-     stereo &#x3D; new StereoGC(args[0]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+     stereo &#x3D; new StereoGC(info[0]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-     stereo &#x3D; new StereoGC(args[0]-&gt;IntegerValue(), args[1]-&gt;IntegerValue());
</code></pre>
                <pre><code class="added">+     stereo &#x3D; new StereoGC(info[0]-&gt;IntegerValue(), info[1]-&gt;IntegerValue());
</code></pre>
                <pre><code class="removed">-   stereo-&gt;Wrap(args.Holder());
  NanReturnValue(args.Holder());
</code></pre>
                <pre><code class="added">+   stereo-&gt;Wrap(info.Holder());
  info.GetReturnValue().Set(info.Holder());
</code></pre>
                <pre><code class="removed">-     ObjectWrap() {
</code></pre>
                <pre><code class="added">+     Nan::ObjectWrap() {
</code></pre>
                <pre><code class="removed">-     Matrix* m0 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[0]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m0 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[0]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-     Matrix* m1 &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(args[1]-&gt;ToObject());
</code></pre>
                <pre><code class="added">+     Matrix* m1 &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(info[1]-&gt;ToObject());
</code></pre>
                <pre><code class="removed">-         NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *disp &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(disparityWrap);
</code></pre>
                <pre><code class="added">+         Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *disp &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(disparityWrap);
</code></pre>
                <pre><code class="removed">-     NanReturnValue(disparityWrap);
</code></pre>
                <pre><code class="added">+     info.GetReturnValue().Set(disparityWrap);
</code></pre>
                <pre><code class="removed">-     NanThrowError(err_msg);
    NanReturnUndefined();
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(err_msg);
    return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/Stereo.h</h3>
          <div class="diff">
                <pre><code class="removed">- class StereoBM: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class StereoBM: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="removed">- class StereoSGBM: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class StereoSGBM: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="removed">- class StereoGC: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class StereoGC: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/VideoCaptureWrap.cc</h3>
          <div class="diff">
                <pre><code class="removed">- v8::Persistent&lt;FunctionTemplate&gt; VideoCaptureWrap::constructor;
</code></pre>
                <pre><code class="added">+ Nan::Persistent&lt;FunctionTemplate&gt; VideoCaptureWrap::constructor;
</code></pre>
                <pre><code class="removed">-   Persistent&lt;Function&gt; cb;
</code></pre>
                <pre><code class="added">+   Nan::Persistent&lt;Function&gt; cb;
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   Local&lt;FunctionTemplate&gt; ctor &#x3D; NanNew&lt;FunctionTemplate&gt;(VideoCaptureWrap::New);
  NanAssignPersistent(constructor, ctor);
</code></pre>
                <pre><code class="added">+   Local&lt;FunctionTemplate&gt; ctor &#x3D; Nan::New&lt;FunctionTemplate&gt;(VideoCaptureWrap::New);
  constructor.Reset(ctor);
</code></pre>
                <pre><code class="removed">-   ctor-&gt;SetClassName(NanNew(&quot;VideoCapture&quot;));
</code></pre>
                <pre><code class="added">+   ctor-&gt;SetClassName(Nan::New(&quot;VideoCapture&quot;).ToLocalChecked());
</code></pre>
                <pre><code class="removed">-   NODE_SET_PROTOTYPE_METHOD(ctor, &quot;read&quot;, Read);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;setWidth&quot;, SetWidth);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;setHeight&quot;, SetHeight);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;setPosition&quot;, SetPosition);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;close&quot;, Close);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;ReadSync&quot;, ReadSync);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;grab&quot;, Grab);
  NODE_SET_PROTOTYPE_METHOD(ctor, &quot;retrieve&quot;, Retrieve);
</code></pre>
                <pre><code class="added">+   Nan::SetPrototypeMethod(ctor, &quot;read&quot;, Read);
  Nan::SetPrototypeMethod(ctor, &quot;setWidth&quot;, SetWidth);
  Nan::SetPrototypeMethod(ctor, &quot;setHeight&quot;, SetHeight);
  Nan::SetPrototypeMethod(ctor, &quot;setPosition&quot;, SetPosition);
  Nan::SetPrototypeMethod(ctor, &quot;close&quot;, Close);
  Nan::SetPrototypeMethod(ctor, &quot;ReadSync&quot;, ReadSync);
  Nan::SetPrototypeMethod(ctor, &quot;grab&quot;, Grab);
  Nan::SetPrototypeMethod(ctor, &quot;retrieve&quot;, Retrieve);
</code></pre>
                <pre><code class="removed">-   target-&gt;Set(NanNew(&quot;VideoCapture&quot;), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="added">+   target-&gt;Set(Nan::New(&quot;VideoCapture&quot;).ToLocalChecked(), ctor-&gt;GetFunction());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-   if (args.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0)
  return NanThrowTypeError(&quot;Cannot Instantiate without new&quot;);
</code></pre>
                <pre><code class="added">+   if (info.This()-&gt;InternalFieldCount() &#x3D;&#x3D; 0)
  return Nan::ThrowTypeError(&quot;Cannot Instantiate without new&quot;);
</code></pre>
                <pre><code class="removed">-   if (args[0]-&gt;IsNumber()) {
    v &#x3D; new VideoCaptureWrap(args[0]-&gt;NumberValue());
</code></pre>
                <pre><code class="added">+   if (info[0]-&gt;IsNumber()) {
    v &#x3D; new VideoCaptureWrap(info[0]-&gt;NumberValue());
</code></pre>
                <pre><code class="removed">-     v &#x3D; new VideoCaptureWrap(std::string(*NanAsciiString(args[0]-&gt;ToString())));
</code></pre>
                <pre><code class="added">+     v &#x3D; new VideoCaptureWrap(std::string(*Nan::Utf8String(info[0]-&gt;ToString())));
</code></pre>
                <pre><code class="removed">-   v-&gt;Wrap(args.This());
</code></pre>
                <pre><code class="added">+   v-&gt;Wrap(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnValue(args.This());
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(info.This());
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-     NanThrowError(&quot;Camera could not be opened&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(&quot;Camera could not be opened&quot;);
</code></pre>
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-     NanThrowError(&quot;Video file could not be opened (opencv reqs. non relative paths)&quot;);
</code></pre>
                <pre><code class="added">+     Nan::ThrowError(&quot;Video file could not be opened (opencv reqs. non relative paths)&quot;);
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if(args.Length() !&#x3D; 1)
  NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   if(info.Length() !&#x3D; 1)
  return;
</code></pre>
                <pre><code class="removed">-   int w &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int w &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if(args.Length() !&#x3D; 1)
  NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   if(info.Length() !&#x3D; 1)
  return;
</code></pre>
                <pre><code class="removed">-   int h &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int h &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   if(args.Length() !&#x3D; 1)
  NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   if(info.Length() !&#x3D; 1)
  return;
</code></pre>
                <pre><code class="removed">-   int pos &#x3D; args[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="added">+   int pos &#x3D; info[0]-&gt;IntegerValue();
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">- class AsyncVCWorker: public NanAsyncWorker {
</code></pre>
                <pre><code class="added">+ class AsyncVCWorker: public Nan::AsyncWorker {
</code></pre>
                <pre><code class="removed">-   AsyncVCWorker(NanCallback *callback, VideoCaptureWrap* vc,
</code></pre>
                <pre><code class="added">+   AsyncVCWorker(Nan::Callback *callback, VideoCaptureWrap* vc,
</code></pre>
                <pre><code class="removed">-       NanAsyncWorker(callback),
</code></pre>
                <pre><code class="added">+       Nan::AsyncWorker(callback),
</code></pre>
                <pre><code class="removed">-     NanScope();
</code></pre>
                <pre><code class="added">+     Nan::HandleScope scope;
</code></pre>
                <pre><code class="removed">-     Local&lt;Object&gt; im_to_return&#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_to_return);
</code></pre>
                <pre><code class="added">+     Local&lt;Object&gt; im_to_return&#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
    Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_to_return);
</code></pre>
                <pre><code class="removed">-       NanNull()
</code></pre>
                <pre><code class="added">+       Nan::Null()
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
  NanAsyncQueueWorker(new AsyncVCWorker(callback, v));
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
  Nan::AsyncQueueWorker(new AsyncVCWorker(callback, v));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   Local&lt;Object&gt; im_to_return&#x3D; NanNew(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; ObjectWrap::Unwrap&lt;Matrix&gt;(im_to_return);
</code></pre>
                <pre><code class="added">+   Local&lt;Object&gt; im_to_return&#x3D; Nan::New(Matrix::constructor)-&gt;GetFunction()-&gt;NewInstance();
  Matrix *img &#x3D; Nan::ObjectWrap::Unwrap&lt;Matrix&gt;(im_to_return);
</code></pre>
                <pre><code class="removed">-   NanReturnValue(im_to_return);
</code></pre>
                <pre><code class="added">+   info.GetReturnValue().Set(im_to_return);
</code></pre>
                <pre><code class="removed">- class AsyncGrabWorker: public NanAsyncWorker {
</code></pre>
                <pre><code class="added">+ class AsyncGrabWorker: public Nan::AsyncWorker {
</code></pre>
                <pre><code class="removed">-   AsyncGrabWorker(NanCallback *callback, VideoCaptureWrap* vc) :
      NanAsyncWorker(callback),
</code></pre>
                <pre><code class="added">+   AsyncGrabWorker(Nan::Callback *callback, VideoCaptureWrap* vc) :
      Nan::AsyncWorker(callback),
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
  NanAsyncQueueWorker(new AsyncGrabWorker(callback, v));
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
  Nan::AsyncQueueWorker(new AsyncGrabWorker(callback, v));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
                <pre><code class="removed">-   NanScope();
  VideoCaptureWrap *v &#x3D; ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(args.This());
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
  VideoCaptureWrap *v &#x3D; Nan::ObjectWrap::Unwrap&lt;VideoCaptureWrap&gt;(info.This());
</code></pre>
                <pre><code class="removed">-   NanCallback *callback &#x3D; new NanCallback(cb.As&lt;Function&gt;());
  NanAsyncQueueWorker(new AsyncVCWorker(callback, v, true, channel));
</code></pre>
                <pre><code class="added">+   Nan::Callback *callback &#x3D; new Nan::Callback(cb.As&lt;Function&gt;());
  Nan::AsyncQueueWorker(new AsyncVCWorker(callback, v, true, channel));
</code></pre>
                <pre><code class="removed">-   NanReturnUndefined();
</code></pre>
                <pre><code class="added">+   return;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/VideoCaptureWrap.h</h3>
          <div class="diff">
                <pre><code class="removed">- class VideoCaptureWrap: public node::ObjectWrap {
</code></pre>
                <pre><code class="added">+ class VideoCaptureWrap: public Nan::ObjectWrap {
</code></pre>
                <pre><code class="removed">-   static Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
                <pre><code class="added">+   static Nan::Persistent&lt;FunctionTemplate&gt; constructor;
</code></pre>
          </div>
      </div>
      <div>
          <h3>Lines changed in src/init.cc</h3>
          <div class="diff">
                <pre><code class="removed">-   NanScope();
</code></pre>
                <pre><code class="added">+   Nan::HandleScope scope;
</code></pre>
          </div>
      </div>
  </section>

  <section id="suggestions">
    <h1>Suggested changes in your JavaScript files</h1>
      <div>
        <h2>buffer</h2>
        <p>Please review changes in Node API for buffer module used in these files:</p>
        <ul>
          <li>examples/face-proxy.js</li>
          <li>examples/mat-put.js</li>
          <li>examples/mat-normalize.js</li>
          <li>lib/opencv.js</li>
          <li>test/unit.js</li>
        </ul>
        <div>
          <p>[<a href="https://iojs.org/api/buffer.html">Docs</a>]</p>
<ul>
<li>External memory is now allocated using <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Typed_arrays">TypedArrays</a>, instead of using <code>SlowBuffer</code> or <code>smalloc</code> as the parent backing.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/63da0dfd3a4460e117240e84b57af2137469497e"><code>63da0df</code></a></li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><a href="https://iojs.org/api/buffer.html#buffer_class_method_buffer_concat_list_totallength"><code>Buffer.concat()</code></a> now always creates a new buffer, even if only called with one element.<ul>
<li>Refs: <a href="https://github.com/nodejs/io.js/commit/f4f16bf03980df4d4366697d40e80da805a38bf8"><code>f4f16bf</code></a>, <a href="https://github.com/nodejs/io.js/issues/1891">#1891</a>, <a href="https://github.com/nodejs/io.js/pull/1937">#1937</a></li>
</ul>
</li>
<li><a href="https://iojs.org/api/buffer.html#buffer_class_slowbuffer"><code>SlowBuffer</code></a> has been repurposed to return a <code>Buffer</code> instance who&#39;s parent backing is not pooled.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/456942a920fe313ebe0b0da366d26ef400ec177e"><code>456942a</code></a></li>
</ul>
</li>
<li><a href="https://iojs.org/api/buffer.html#buffer_buf_tojson"><code>Buffer.prototype.toJSON()</code></a>&#39;s output is no longer the same as an array. Instead it is an object specifically tagged as a buffer, which can be recovered by passing it to (a new overload of) the <code>Buffer</code> constructor.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/840a29fc0fd256a63b3f2f5e7528de5107a608a3"><code>840a29f</code></a></li>
</ul>
</li>
<li><code>Buffer.prototype.parent</code> is now a getter that points to <code>buffer.buffer</code> if the buffer&#39;s size is greater than zero.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/63da0dfd3a4460e117240e84b57af2137469497e"><code>63da0df</code></a></li>
</ul>
</li>
<li><code>Buffer.prototype.offset</code> is now a read-only getter that returns <code>buffer.byteOffset</code>.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/63da0dfd3a4460e117240e84b57af2137469497e"><code>63da0df</code></a></li>
</ul>
</li>
<li><a href="https://iojs.org/api/buffer.html#buffer_buf_fill_value_offset_end"><code>Buffer.prototype.fill()</code></a> now accepts multi-character strings and will fill with the entire passed value. Additionally, <code>fill()</code> now returns its <code>buffer</code> and can be chained.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/57ed3daebfe4700b14cd551f50240f1a634dbd64"><code>57ed3da</code></a></li>
</ul>
</li>
<li><code>Buffer.prototype._charsWritten</code> no longer is written to, nor exists.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/ccda6bb3ac99ee46508860385128f47a3d5547e5"><code>ccda6bb</code></a></li>
</ul>
</li>
</ul>
<h4 id="buffer-changes-from-v8">Buffer changes from V8</h4>
<p>Implementation changes in V8 have caused subtle impacts how buffers work with encodings in certain cases.</p>
<ul>
<li><code>(new Buffer(&#39;text\0!&#39;, &#39;ascii&#39;)).toString()</code> outputs <code>&#39;text !&#39;</code> in 0.10 and <code>&#39;text\u0000!&#39;</code> in 0.12.</li>
<li>Invalid unicode characters are replaced to no longer become invalid.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/issues/2344">#2344</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <hr>
      <div>
        <h2>process</h2>
        <p>Please review changes in Node API for process module used in these files:</p>
        <ul>
          <li>lib/opencv.js</li>
          <li>test/examples.js</li>
        </ul>
        <div>
          <p>[<a href="https://iojs.org/api/process.html">Docs</a>]</p>
<ul>
<li>Added the concept of <code>beforeExit</code> time.<ul>
<li>Before the process emits <a href="https://iojs.org/api/process.html#process_event_exit"><code>&#39;exit&#39;</code></a> and begins shutting down, it will emit a <a href="https://iojs.org/api/process.html#process_event_beforeexit"><code>&#39;beforeExit&#39;</code></a> event. Code that is run in the <code>&#39;beforeExit&#39;</code> event can schedule async operations that will hold the event loop open, unlike <code>&#39;exit&#39;</code> where it is too late to async operations.</li>
<li>Refs: <a href="https://github.com/nodejs/node/commit/a2eeb43deda58e7bbb8fcf24b934157992b937c0"><code>a2eeb43</code></a></li>
</ul>
</li>
<li>Chunked writes to sdtout/stderr will now be lost if the process is terminated early.<ul>
<li>Chunked writes happen when the string to be written is beyond a certain, fairly large, size.</li>
<li>Refs: <a href="https://github.com/nodejs/node/issues/784">#784</a>, <a href="https://github.com/nodejs/node/pull/1771">#1771</a></li>
</ul>
</li>
<li><a href="https://iojs.org/api/process.html#process_process_kill_pid_signal"><code>process.kill()</code></a> now throws errors on non-numeric input.<ul>
<li>Strings that can be coerced to numbers still work. e.g. <code>process.kill(&#39;0&#39;)</code>.</li>
<li>Refs: <a href="https://github.com/nodejs/node/commit/832ec1cd507ed344badd2ed97d3da92975650a95"><code>832ec1c</code></a>, <a href="https://github.com/nodejs/node/commit/743a009bad64c4302a724f70c42d73601a16aed4"><code>743a009</code></a></li>
</ul>
</li>
<li><code>process.maxTickDepth</code> has been removed, allowing <a href="https://iojs.org/api/process.html#process_process_nexttick_callback_arg"><code>process.nextTick()</code></a> to starve I/O indefinitely.<ul>
<li>This is due to adding <a href="https://iojs.org/api/timers.html#timers_setimmediate_callback_arg"><code>setImmediate()</code></a> in 0.10.</li>
<li>It is suggested you use <code>setImmediate()</code> over <code>process.NextTick()</code>. <code>setImmediate()</code> likely does what you are hoping for (a more efficient <code>setTimeout(..., 0)</code>), and runs after this tick&#39;s I/O. <code>process.nextTick()</code> does not actually run in the &quot;next&quot; tick anymore and will block I/O as if it were a synchronous operation.</li>
<li>Refs: <a href="https://github.com/nodejs/node/commit/0761c90204d7a0134c657e20f91bd83bfa6e677a"><code>0761c90</code></a>, <a href="https://github.com/nodejs/node/commit/9a6c0853bc164ad2d76f51cdcb0771e881cd0a5f"><code>9a6c085</code></a></li>
</ul>
</li>
<li><a href="https://github.com/nodejs/node/pull/1978"><code>process.send()</code></a> is now always asynchronous, where previously it was blocking on Unix.<ul>
<li>Pull request <a href="https://github.com/nodejs/node/pull/2620">#2620</a>, which should land before 4.0.0, will make <code>send()</code> accept a callback as the last argument, with will be called with one argument: <code>null</code> if it succeeded, or an <code>Error</code> if it failed.</li>
<li>Refs: <a href="https://github.com/nodejs/node/issues/760">#760</a>, <a href="https://github.com/nodejs/node/pull/2620">#2620</a></li>
</ul>
</li>
</ul>
<h4 id="signal-handling">Signal handling</h4>
<p>In node 0.10.x, exit from a fatal signal was accomplished by a signal handler in
node which called <code>exit(128 + signo)</code>.  So for <code>SIGINT</code> (signal 2), a node process
observing the exit of a spawned node process would observe that process exiting 130,
but no signal would be noted (see <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/waitid.html"><code>waitid(2)</code></a> for more information on how a process
waiting for another determines if the waitee exited due to a signal).  In node
0.12.x, a node process observing the exit of a spawned child node process will
see a null <code>code</code>, and a <code>&#39;SIGINT&#39;</code> as the signal.</p>
<p>Here is a pair of test programs which illustrates the difference.</p>
<pre><code>$ cat sleeper.js
setTimeout(function () {}, 300000)

$ cat test.js
var cp = require(&quot;child_process&quot;)
var p = cp.spawn(&quot;node&quot;, [&quot;sleeper.js&quot;])
p.on(&#39;exit&#39;, function (code, signal) {
  console.log(&quot;code=&quot; + code + &quot;, signal=&quot; + signal)
})
setTimeout(function () { p.kill(&#39;SIGINT&#39;) }, 2000)
</code></pre><p>On node 0.10 this produces:</p>
<pre><code>$ node test.js
code=130, signal=null
</code></pre><p>On node 0.12+ this produces:</p>
<pre><code>$ node test.js
code=null, signal=SIGINT
</code></pre><p>This can be a subtle porting issue for multi-process node environments which care
about signals (such as test harnesses).  This change was introduced by
<a href="https://github.com/joyent/node/commit/c61b0e9cbc748c5e90fc5e25e4fb490b4104cae3"><code>c61b0e9</code>—<code>main: Handle SIGINT properly</code></a>.</p>

        </div>
      </div>
      <hr>
      <div>
        <h2>util</h2>
        <p>Please review changes in Node API for util module used in these files:</p>
        <ul>
          <li>lib/opencv.js</li>
        </ul>
        <div>
          <p>[<a href="https://iojs.org/api/util.html">Docs</a>]</p>
<ul>
<li><code>util.is*()</code> (<code>isArray()</code> ... <code>isUndefined()</code>) type-checking functions were added in 0.12 but are scheduled for deprecation. Please use user-land solutions instead.<ul>
<li>The type checking these use will be come brittle with the eventual addition of <code>Symbol.toStringTag</code>.</li>
<li>Refs: <a href="https://github.com/nodejs/node/pull/2447">#2447</a></li>
</ul>
</li>
<li>Updated <a href="https://iojs.org/api/util.html#util_util_format_format"><code>util.format()</code></a> to receive several changes:<ul>
<li><code>-0</code> is now displayed as such, instead of as <code>0</code>.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/b3e4fc6a48b97b52bd19de43c76b7082dcab4988"><code>b3e4fc6</code></a></li>
</ul>
</li>
<li>Anything that is <code>instanceof Error</code> is now formatted as an error.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/684dd28a6c684532336777348875ac11305727b9"><code>684dd28</code></a></li>
</ul>
</li>
<li>Circular references in JavaScript objects are now handled for the <code>%j</code> specifier.<ul>
<li>Refs:  <a href="https://github.com/nodejs/node/commit/2cd7adc7f44e4dfe440162a31a168e6aa9a8cea1"><code>2cd7adc</code></a></li>
</ul>
</li>
<li>Custom <code>inspect</code> functions now receive any arguments passed to <code>util.inspect</code>.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/07774e6b9570f90166a54fa87af74b8a7cf9926a"><code>07774e6</code></a></li>
</ul>
</li>
<li>Displays the constructor name if available.<ul>
<li>Refs: <a href="https://github.com/nodejs/node/commit/7d14dd9b5e78faabb95d454a79faa513d0bbc2a5"><code>7d14dd9</code></a></li>
</ul>
</li>
</ul>
</li>
<li>The following utilities were deprecated in <a href="https://github.com/nodejs/node/commit/896b2aa7074fc886efd7dd0a397d694763cac7ce"><code>896b2aa</code></a>:<ul>
<li><code>util.p()</code>, <code>util.debug()</code>, <code>util.error()</code> — Use <a href="https://iojs.org/api/console.html#console_console_error_data"><code>console.error()</code></a> instead.</li>
<li><code>util.print()</code>, <code>util.puts()</code> — Use <a href="https://iojs.org/api/console.html#console_console_log_data"><code>console.log()</code></a> instead.</li>
<li><code>util.exec()</code> — Now found at <a href="https://iojs.org/api/child_process.html#child_process_child_process_exec_command_options_callback"><code>child_process.exec()</code></a>.</li>
<li><code>util.pump()</code> — Use <a href="https://iojs.org/api/stream.html#stream_readable_pipe_destination_options"><code>ReadableStream.prototype.pipe()</code></a> instead.</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <hr>
  </section>
</body>
</html>
